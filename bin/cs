#!/usr/bin/env bash
# ABOUTME: Claude Code session manager with artifact tracking and tmux integration
# ABOUTME: Creates isolated session workspaces with automatic documentation and file organization

set -euo pipefail

# Configuration
VERSION="2025.12.22"
SESSIONS_ROOT="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
CLAUDE_CODE_BIN="${CLAUDE_CODE_BIN:-claude}"
REPO_URL="https://github.com/hex/claude-sessions"
RAW_URL="https://raw.githubusercontent.com/hex/claude-sessions/main"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
WHITE='\033[0;97m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Utility functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${GREEN}$1${NC}"
}

show_help() {
    cat <<EOF
cs $VERSION - Claude Code session manager

Usage: cs <session-name>    Create or resume a session
       cs <command>         Run a subcommand

Commands:
  <name>              Create or resume session <name>
  list, ls            List all sessions
  remove, rm <name>   Remove a session
  update              Update cs to latest version
    --check, -c       Check for updates without installing
    --force, -f       Force reinstall even if up to date
  help, -h, --help    Show this help message
  version, -v         Show version

Environment:
  CS_SESSIONS_ROOT    Override sessions directory (default: ~/.claude-sessions)
  CLAUDE_CODE_BIN     Override claude binary name (default: claude)

Examples:
  cs debug-api        Create or resume 'debug-api' session
  cs list             List all sessions
  cs rm old-session   Remove 'old-session'
  cs update --check   Check for updates

Sessions are stored in: $SESSIONS_ROOT
EOF
}

warn() {
    echo -e "${YELLOW}$1${NC}"
}

# Fetch latest version from GitHub
get_remote_version() {
    local remote_cs
    remote_cs=$(curl -fsSL "$RAW_URL/bin/cs" 2>/dev/null) || return 1
    echo "$remote_cs" | grep '^VERSION=' | head -1 | cut -d'"' -f2
}

# Compare versions (YYYY.MM.N format). Returns 0 if v1 > v2, 1 otherwise
version_greater() {
    local v1="$1" v2="$2"

    # Split into components
    local y1 m1 n1 y2 m2 n2
    IFS='.' read -r y1 m1 n1 <<< "$v1"
    IFS='.' read -r y2 m2 n2 <<< "$v2"

    # Compare year
    if [ "$y1" -gt "$y2" ] 2>/dev/null; then return 0; fi
    if [ "$y1" -lt "$y2" ] 2>/dev/null; then return 1; fi

    # Compare month
    if [ "$m1" -gt "$m2" ] 2>/dev/null; then return 0; fi
    if [ "$m1" -lt "$m2" ] 2>/dev/null; then return 1; fi

    # Compare patch
    if [ "$n1" -gt "$n2" ] 2>/dev/null; then return 0; fi

    return 1
}

# Check for updates
check_update() {
    local remote_version
    remote_version=$(get_remote_version) || {
        error "Failed to check for updates. Check your internet connection."
    }

    echo -e "Current version: ${GREEN}$VERSION${NC}"
    echo -e "Latest version:  ${GREEN}$remote_version${NC}"

    if version_greater "$remote_version" "$VERSION"; then
        echo ""
        info "Update available. Run 'cs update' to install."
        return 0
    else
        echo ""
        info "Already up to date."
        return 0
    fi
}

# Perform update
do_update() {
    local force="${1:-false}"
    local remote_version

    remote_version=$(get_remote_version) || {
        error "Failed to fetch update. Check your internet connection."
    }

    if [ "$force" != "true" ]; then
        if ! version_greater "$remote_version" "$VERSION"; then
            info "Already up to date ($VERSION)"
            return 0
        fi
    fi

    echo -e "Updating cs from ${YELLOW}$VERSION${NC} to ${GREEN}$remote_version${NC}..."
    echo ""

    # Download and run install.sh
    local install_script
    install_script=$(curl -fsSL "$RAW_URL/install.sh" 2>/dev/null) || {
        error "Failed to download installer."
    }

    # Run the installer
    bash -c "$install_script"

    # Clear update cache so notification disappears
    rm -f "$HOME/.cache/cs/update-check"

    # Exit immediately to prevent bash from reading more of the old script
    # (the file was just overwritten, continuing would cause errors)
    exit 0
}

# Check for updates periodically and notify (non-blocking)
UPDATE_CACHE="$HOME/.cache/cs/update-check"
UPDATE_CHECK_INTERVAL=3600  # 1 hour in seconds
UPDATE_AVAILABLE=""  # Set by check_update_notify if update available

check_update_notify() {
    local cache_dir
    cache_dir="$(dirname "$UPDATE_CACHE")"
    mkdir -p "$cache_dir"

    local now
    now=$(date +%s)

    # Check if cache exists and is fresh
    if [ -f "$UPDATE_CACHE" ]; then
        local cache_time cached_version
        read -r cache_time cached_version < "$UPDATE_CACHE" 2>/dev/null || true

        # If cache is fresh, use it
        if [ -n "$cache_time" ] && [ $((now - cache_time)) -lt $UPDATE_CHECK_INTERVAL ]; then
            # Set update available if cached version is newer
            if [ -n "$cached_version" ] && version_greater "$cached_version" "$VERSION"; then
                UPDATE_AVAILABLE="$cached_version"
            fi
            return 0
        fi
    fi

    # No fresh cache - do a quick synchronous check
    local remote_version
    remote_version=$(get_remote_version 2>/dev/null) || remote_version=""

    if [ -n "$remote_version" ]; then
        echo "$now $remote_version" > "$UPDATE_CACHE"
        if version_greater "$remote_version" "$VERSION"; then
            UPDATE_AVAILABLE="$remote_version"
        fi
    fi
}

# Check dependencies
check_dependencies() {
    local missing=()

    # Extract just the binary name (first word) for the check
    local claude_bin
    claude_bin="${CLAUDE_CODE_BIN%% *}"
    command -v "$claude_bin" >/dev/null 2>&1 || missing+=("claude-code")

    if [ ${#missing[@]} -gt 0 ]; then
        error "Missing required dependencies: ${missing[*]}"
    fi
}

# Validate session name
validate_session_name() {
    local name="$1"

    if [ -z "$name" ]; then
        error "Session name cannot be empty"
    fi

    if ! [[ "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        error "Session name must contain only alphanumeric characters, hyphens, and underscores"
    fi
}

# Create session directory structure
create_session_structure() {
    local session_dir="$1"

    mkdir -p "$session_dir"/{artifacts,logs}

    # Create README.md
    cat > "$session_dir/README.md" << EOF
# Session: $(basename "$session_dir")

**Started:** $(date '+%Y-%m-%d %H:%M:%S')
**Location:** $(hostname):$(pwd)

## Objective

[Describe what you're trying to accomplish in this session]

## Environment

[Describe the system, server, or context you're working in]

## Outcome

[To be filled when session is complete - summarize what was accomplished]
EOF

    # Create discoveries.md
    cat > "$session_dir/discoveries.md" << 'EOF'
# Discoveries & Notes

Document what you learn and observe during this session:

## Findings
- System architecture and configuration
- Existing patterns and conventions
- Dependencies and relationships
- Unexpected behaviors or gotchas

## Ideas & Observations
- Potential improvements
- Questions to investigate
- Useful commands or procedures

Update this file throughout the session as you discover new information.
EOF

    # Create changes.md
    cat > "$session_dir/changes.md" << 'EOF'
# Changes Made

Document all modifications, fixes, and changes made during this session:

## Files Modified

-

## Configuration Changes

-

## Bug Fixes

-

## Scripts Created

-

Update this file as you make changes throughout the session.
EOF

    # Create CLAUDE.md with session-specific instructions
    cat > "$session_dir/CLAUDE.md" << 'EOF'
# Session Documentation Protocol

This is a Claude Code session managed by the cs tool. This session has automatic artifact tracking and documentation support.

## Session Files - READ THESE ON RESUME

When resuming this session, read the following files to restore context:

1. **summary.md** - If exists, read first for previous session overview
2. **README.md** - Session objective, environment, and outcome
3. **discoveries.md** - Findings, observations, and ideas
4. **changes.md** - Modifications and fixes made
5. **artifacts/MANIFEST.json** - List of tracked artifacts

## Artifact Auto-Tracking

Scripts and configuration files you create are **automatically saved to artifacts/**:

- Scripts: .sh, .bash, .zsh, .py, .js, .ts, .rb, .pl
- Configs: .conf, .config, .json, .yaml, .yml, .toml, .ini, .env

When you use the Write tool for these file types, they are automatically redirected to the artifacts/ directory and tracked in MANIFEST.json.

## Documentation Discipline

Update the markdown documentation files throughout the session:

1. **Start of session:** Fill in README.md objective and environment
2. **As you work:** Update discoveries.md with findings and changes.md with modifications
3. **End of session:** Complete the README.md outcome section

Treat these files as a lab notebook - document as you go, not just at the end.

## Summary Command

When the session is complete, use the `/summary` command to generate an intelligent summary of the entire session. This will create a summary.md file synthesizing all documentation.

## Best Practices

- Document discoveries as you find them - don't wait until the end
- Use artifacts/ for any reusable scripts or configs
- changes.md is updated automatically when files are modified
- Run `/summary` at the end to create a cohesive record
EOF

    # Initialize empty MANIFEST.json
    echo "[]" > "$session_dir/artifacts/MANIFEST.json"

    # Initialize session log
    cat > "$session_dir/logs/session.log" << EOF
Claude Code Session Log
Session: $(basename "$session_dir")
Started: $(date '+%Y-%m-%d %H:%M:%S')
Location: $(hostname):$(pwd)

================================================================================

EOF
}

# Migrate existing session to latest format
migrate_session() {
    local session_dir="$1"
    local claude_md="$session_dir/CLAUDE.md"

    # Check if CLAUDE.md needs migration (old format has "## Session Structure")
    if [ -f "$claude_md" ] && grep -q "^## Session Structure" "$claude_md"; then
        cat > "$claude_md" << 'EOF'
# Session Documentation Protocol

This is a Claude Code session managed by the cs tool. This session has automatic artifact tracking and documentation support.

## Session Files - READ THESE ON RESUME

When resuming this session, read the following files to restore context:

1. **summary.md** - If exists, read first for previous session overview
2. **README.md** - Session objective, environment, and outcome
3. **discoveries.md** - Findings, observations, and ideas
4. **changes.md** - Modifications and fixes made
5. **artifacts/MANIFEST.json** - List of tracked artifacts

## Artifact Auto-Tracking

Scripts and configuration files you create are **automatically saved to artifacts/**:

- Scripts: .sh, .bash, .zsh, .py, .js, .ts, .rb, .pl
- Configs: .conf, .config, .json, .yaml, .yml, .toml, .ini, .env

When you use the Write tool for these file types, they are automatically redirected to the artifacts/ directory and tracked in MANIFEST.json.

## Documentation Discipline

Update the markdown documentation files throughout the session:

1. **Start of session:** Fill in README.md objective and environment
2. **As you work:** Update discoveries.md with findings and changes.md with modifications
3. **End of session:** Complete the README.md outcome section

Treat these files as a lab notebook - document as you go, not just at the end.

## Summary Command

When the session is complete, use the `/summary` command to generate an intelligent summary of the entire session. This will create a summary.md file synthesizing all documentation.

## Best Practices

- Document discoveries as you find them - don't wait until the end
- Use artifacts/ for any reusable scripts or configs
- changes.md is updated automatically when files are modified
- Run `/summary` at the end to create a cohesive record
EOF
        warn "Migrated CLAUDE.md to latest format"
    fi
}

# Get file modification time (cross-platform)
get_mtime() {
    local file="$1"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$file" 2>/dev/null || echo "-"
    else
        stat -c "%y" "$file" 2>/dev/null | cut -d'.' -f1 | cut -d':' -f1,2 || echo "-"
    fi
}

# List all sessions
list_sessions() {
    if [ ! -d "$SESSIONS_ROOT" ]; then
        info "No sessions found"
        return 0
    fi

    local sessions=()
    while IFS= read -r -d '' dir; do
        sessions+=("$(basename "$dir")")
    done < <(find "$SESSIONS_ROOT" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)

    if [ ${#sessions[@]} -eq 0 ]; then
        info "No sessions found"
        return 0
    fi

    # Find max session name length for column alignment
    local max_len=7  # minimum "SESSION" header length
    for session in "${sessions[@]}"; do
        if [ ${#session} -gt $max_len ]; then
            max_len=${#session}
        fi
    done

    # Print header
    printf "${YELLOW}%-${max_len}s  %-16s  %s${NC}\n" "SESSION" "CREATED" "MODIFIED"
    printf "%-${max_len}s  %-16s  %s\n" "$(printf '%*s' "$max_len" '' | tr ' ' '-')" "----------------" "----------------"

    # Print sessions
    for session in "${sessions[@]}"; do
        local session_dir="$SESSIONS_ROOT/$session"
        local created="-"
        local modified="-"

        if [ -f "$session_dir/logs/session.log" ]; then
            local started
            started=$(head -4 "$session_dir/logs/session.log" | grep "Started:" | cut -d' ' -f2-)
            if [ -n "$started" ]; then
                created=$(echo "$started" | cut -d':' -f1,2)
            fi
            modified=$(get_mtime "$session_dir/logs/session.log")
        fi

        printf "${GREEN}%-${max_len}s${NC}  %-16s  %s\n" "$session" "$created" "$modified"
    done
}

# Remove a session
remove_session() {
    local session_name="$1"

    if [ -z "$session_name" ]; then
        error "Usage: cs remove <session-name>"
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ ! -d "$session_dir" ]; then
        error "Session not found: $session_name"
    fi

    # Confirm deletion
    read -r -p $'\033[0;31mRemove session '"'$session_name'"$'? [y/N] \033[0m' confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        info "Cancelled"
        return 0
    fi

    rm -rf "$session_dir"
    info "Removed session: $session_name"
}

# Launch Claude Code
launch_claude_code() {
    local session_name="$1"
    local session_dir="$2"
    local is_new="$3"

    # Set environment variables
    export CLAUDE_SESSION_NAME="$session_name"
    export CLAUDE_SESSION_DIR="$session_dir"
    export CLAUDE_ARTIFACT_DIR="$session_dir/artifacts"

    # Status indicator
    local status_icon status_text
    if [ "$is_new" = "true" ]; then
        status_icon="+"
        status_text="new"
    else
        status_icon="↻"
        status_text="resuming"
    fi

    # Display banner
    echo ""
    echo -e "${GREEN}▌${NC} ${BOLD}cs${NC} ${DIM}$VERSION${NC}"
    echo -e "${GREEN}▌${NC} ${WHITE}${BOLD}$session_name${NC} ${DIM}($status_icon $status_text)${NC}"
    echo -e "${GREEN}▌${NC} ${DIM}$session_dir${NC}"
    if [ -n "$UPDATE_AVAILABLE" ]; then
        echo -e "${YELLOW}▌${NC} ${YELLOW}Update available: $VERSION -> $UPDATE_AVAILABLE${NC} ${DIM}(cs update)${NC}"
    fi
    echo ""

    cd "$session_dir"
    # shellcheck disable=SC2086
    exec $CLAUDE_CODE_BIN
}

# Main function
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    local cmd="$1"

    # Handle subcommands
    case "$cmd" in
        -h|--help|help)
            show_help
            return 0
            ;;
        -v|--version|version)
            echo "cs $VERSION"
            return 0
            ;;
        list|ls)
            list_sessions
            return 0
            ;;
        remove|rm)
            remove_session "${2:-}"
            return 0
            ;;
        update)
            local update_arg="${2:-}"
            case "$update_arg" in
                --check|-c)
                    check_update
                    ;;
                --force|-f)
                    do_update "true"
                    ;;
                "")
                    do_update
                    ;;
                *)
                    error "Unknown option: $update_arg. Use 'cs update [--check|--force]'"
                    ;;
            esac
            return 0
            ;;
    esac

    local session_name="$cmd"

    # Validate inputs
    validate_session_name "$session_name"
    check_dependencies

    # Check for updates (non-blocking)
    check_update_notify

    # Define paths
    local session_dir="$SESSIONS_ROOT/$session_name"
    local is_new="false"

    # Create session structure if needed
    if [ ! -d "$session_dir" ]; then
        is_new="true"
        create_session_structure "$session_dir"
    else
        migrate_session "$session_dir"
    fi

    # Launch Claude Code
    launch_claude_code "$session_name" "$session_dir" "$is_new"
}

main "$@"
