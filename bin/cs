#!/usr/bin/env bash
# ABOUTME: Claude Code session manager with artifact tracking and git sync
# ABOUTME: Creates isolated session workspaces with automatic documentation and file organization

set -euo pipefail

# Configuration
VERSION="2026.01.69"
SESSIONS_ROOT="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
CLAUDE_CODE_BIN="${CLAUDE_CODE_BIN:-claude}"
REPO_URL="https://github.com/hex/claude-sessions"
RAW_URL="https://raw.githubusercontent.com/hex/claude-sessions/main"

# Colors - Tokyo Night palette
RED='\033[38;2;247;118;142m'      # #f7768e
GREEN='\033[38;2;158;206;106m'    # #9ece6a
YELLOW='\033[38;2;224;175;104m'   # #e0af68
BLUE='\033[38;2;122;162;247m'     # #7aa2f7
CYAN='\033[38;2;125;207;255m'     # #7dcfff
PURPLE='\033[38;2;187;154;247m'   # #bb9af7
COMMENT='\033[38;2;86;95;137m'    # #565f89
WHITE='\033[38;2;169;177;214m'    # #a9b1d6 (foreground)
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# Utility functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${GREEN}$1${NC}"
}

show_help() {
    cat <<EOF
cs $VERSION - Claude Code session manager

Usage: cs <session-name>              Create or resume a session
       cs <session-name> -sync <cmd>  Run sync command on session
       cs <session-name> -secrets <cmd>  Run secrets command on session
       cs -<command>                  Run a global subcommand

Commands:
  <name>              Create or resume session <name>
  <name> -sync <cmd>  Run sync command on <name> without launching session
  <name> -secrets <cmd>  Run secrets command on <name> without launching session
  -list, -ls          List all sessions
  -remove, -rm <name> Remove a session
  -sync, -s <cmd>     Sync current session (requires CLAUDE_SESSION_NAME)
  -secrets <cmd>      Manage current session secrets (requires CLAUDE_SESSION_NAME)
  -update             Update cs to latest version
    --check, -c       Check for updates without installing
    --force, -f       Force reinstall even if up to date
  -uninstall          Uninstall cs and all components
  -help, -h           Show this help message
  -version, -v        Show version

Secrets Commands:
  set, store <name>   Store a secret (prompts if value not provided)
  get <name>          Retrieve a secret value
  list, ls            List all secrets for session
  delete, rm <name>   Delete a secret
  purge               Delete ALL secrets for session
  export              Export secrets as environment variables
  backend             Show which storage backend is active

Sync Commands:
  remote [url]        Add remote to git repo (uses CS_SYNC_PREFIX if URL not provided)
  push                Commit changes (pushes to remote if configured)
  pull                Pull changes from remote (skips if local-only)
  status, st          Show sync status
  auto [on|off]       Toggle/show auto-sync setting
  clone <session|url> [name]  Clone session from remote (uses CS_SYNC_PREFIX if session name)

Environment:
  CS_SESSIONS_ROOT      Override sessions directory (default: ~/.claude-sessions)
  CLAUDE_CODE_BIN       Override claude binary name (default: claude)
  CLAUDE_SESSION_NAME   Current session name (set automatically)
  CS_SECRETS_PASSWORD   Master password for encrypted secrets backend
  CS_SYNC_PREFIX        Git remote prefix (e.g., git@github.com:user/)

Examples:
  cs debug-api                      Create or resume 'debug-api' session (git + auto-sync)
  cs my-session -sync push          Commit changes manually during session
  cs my-session -sync remote <url>  Add remote to existing local repo
  cs my-session -sync auto off      Disable auto-commit (on by default)
  cs -sync clone other-session    Clone session (uses CS_SYNC_PREFIX)
  cs my-session -secrets list     List secrets for 'my-session'
  cs -list                        List all sessions
  cs -rm old-session              Remove 'old-session'

Sessions are stored in: $SESSIONS_ROOT
EOF
}

warn() {
    echo -e "${YELLOW}$1${NC}"
}

# Fetch latest version from GitHub
get_remote_version() {
    local remote_cs cache_bust
    cache_bust=$(date +%s)
    remote_cs=$(curl -fsSL "$RAW_URL/bin/cs?cb=$cache_bust" 2>/dev/null) || return 1
    echo "$remote_cs" | grep '^VERSION=' | head -1 | cut -d'"' -f2
}

# Compare versions (YYYY.MM.N format). Returns 0 if v1 > v2, 1 otherwise
version_greater() {
    local v1="$1" v2="$2"

    # Split into components
    local y1 m1 n1 y2 m2 n2
    IFS='.' read -r y1 m1 n1 <<< "$v1"
    IFS='.' read -r y2 m2 n2 <<< "$v2"

    # Compare year
    if [ "$y1" -gt "$y2" ] 2>/dev/null; then return 0; fi
    if [ "$y1" -lt "$y2" ] 2>/dev/null; then return 1; fi

    # Compare month
    if [ "$m1" -gt "$m2" ] 2>/dev/null; then return 0; fi
    if [ "$m1" -lt "$m2" ] 2>/dev/null; then return 1; fi

    # Compare patch
    if [ "$n1" -gt "$n2" ] 2>/dev/null; then return 0; fi

    return 1
}

# Check for updates
check_update() {
    local remote_version
    remote_version=$(get_remote_version) || {
        error "Failed to check for updates. Check your internet connection."
    }

    echo -e "Current version: ${GREEN}$VERSION${NC}"
    echo -e "Latest version:  ${GREEN}$remote_version${NC}"

    if version_greater "$remote_version" "$VERSION"; then
        echo ""
        info "Update available. Run 'cs -update' to install."
        return 0
    else
        echo ""
        info "Already up to date."
        return 0
    fi
}

# Perform update
do_update() {
    local force="${1:-false}"
    local remote_version

    remote_version=$(get_remote_version) || {
        error "Failed to fetch update. Check your internet connection."
    }

    if [ "$force" != "true" ]; then
        if ! version_greater "$remote_version" "$VERSION"; then
            info "Already up to date ($VERSION)"
            return 0
        fi
    fi

    echo ""
    echo -e "   ${COMMENT}Updating${NC} cs ${COMMENT}from${NC} ${PURPLE}$VERSION${NC} ${COMMENT}→${NC} ${GREEN}$remote_version${NC}"
    echo ""

    # Download and run install.sh (with cache busting)
    local install_script cache_bust
    cache_bust=$(date +%s)
    install_script=$(curl -fsSL "$RAW_URL/install.sh?cb=$cache_bust" 2>/dev/null) || {
        error "Failed to download installer."
    }

    # Run the installer
    bash -c "$install_script"

    # Clear update cache so notification disappears
    rm -f "$HOME/.cache/cs/update-check"

    # Exit immediately to prevent bash from reading more of the old script
    # (the file was just overwritten, continuing would cause errors)
    exit 0
}

# Check for updates periodically and notify (non-blocking)
UPDATE_CACHE="$HOME/.cache/cs/update-check"
UPDATE_CHECK_INTERVAL=3600  # 1 hour in seconds
UPDATE_AVAILABLE=""  # Set by check_update_notify if update available

check_update_notify() {
    local cache_dir
    cache_dir="$(dirname "$UPDATE_CACHE")"
    mkdir -p "$cache_dir"

    local now
    now=$(date +%s)

    # Check if cache exists and is fresh
    if [ -f "$UPDATE_CACHE" ]; then
        local cache_time cached_version
        read -r cache_time cached_version < "$UPDATE_CACHE" 2>/dev/null || true

        # If cache is fresh, use it
        if [ -n "$cache_time" ] && [ $((now - cache_time)) -lt $UPDATE_CHECK_INTERVAL ]; then
            # Set update available if cached version is newer
            if [ -n "$cached_version" ] && version_greater "$cached_version" "$VERSION"; then
                UPDATE_AVAILABLE="$cached_version"
            fi
            return 0
        fi
    fi

    # No fresh cache - do a quick synchronous check
    local remote_version
    remote_version=$(get_remote_version 2>/dev/null) || remote_version=""

    if [ -n "$remote_version" ]; then
        echo "$now $remote_version" > "$UPDATE_CACHE"
        if version_greater "$remote_version" "$VERSION"; then
            UPDATE_AVAILABLE="$remote_version"
        fi
    fi
}

# Check dependencies
check_dependencies() {
    local missing=()

    # Extract just the binary name (first word) for the check
    local claude_bin
    claude_bin="${CLAUDE_CODE_BIN%% *}"
    command -v "$claude_bin" >/dev/null 2>&1 || missing+=("claude-code")

    if [ ${#missing[@]} -gt 0 ]; then
        error "Missing required dependencies: ${missing[*]}"
    fi
}

# Validate session name
validate_session_name() {
    local name="$1"

    if [ -z "$name" ]; then
        error "Session name cannot be empty"
    fi

    if ! [[ "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        error "Session name must contain only alphanumeric characters, hyphens, and underscores"
    fi
}

# Create session directory structure
create_session_structure() {
    local session_dir="$1"

    mkdir -p "$session_dir"/{artifacts,logs}

    # Create README.md
    cat > "$session_dir/README.md" << EOF
# Session: $(basename "$session_dir")

**Started:** $(date '+%Y-%m-%d %H:%M:%S')
**Location:** $(hostname):$(pwd)

## Objective

[Describe what you're trying to accomplish in this session]

## Environment

[Describe the system, server, or context you're working in]

## Outcome

[To be filled when session is complete - summarize what was accomplished]
EOF

    # Create discoveries.md
    cat > "$session_dir/discoveries.md" << 'EOF'
# Discoveries & Notes

EOF

    # Create changes.md
    cat > "$session_dir/changes.md" << 'EOF'
# Changes Log

EOF

    # Create CLAUDE.md with session-specific instructions
    cat > "$session_dir/CLAUDE.md" << 'EOF'
# Session Documentation Protocol

This is a Claude Code session managed by the cs tool. This session has automatic artifact tracking and documentation support.

## Session Files - READ THESE ON RESUME

When resuming this session, read the following files to restore context:

1. **summary.md** - If exists, read first for previous session overview
2. **README.md** - Session objective, environment, and outcome
3. **discoveries.md** - Findings, observations, and ideas
4. **changes.md** - Modifications and fixes made
5. **artifacts/MANIFEST.json** - List of tracked artifacts

## Artifact Auto-Tracking

Scripts and configuration files you create are **automatically saved to artifacts/**:

- Scripts: .sh, .bash, .zsh, .py, .js, .ts, .rb, .pl
- Configs: .conf, .config, .json, .yaml, .yml, .toml, .ini, .env

When you use the Write tool for these file types, they are automatically redirected to the artifacts/ directory and tracked in MANIFEST.json.

## Documentation Discipline

Update the markdown documentation files throughout the session:

1. **Start of session:** Fill in README.md objective and environment
2. **As you work:** Update discoveries.md with findings and changes.md with modifications
3. **End of session:** Complete the README.md outcome section

Treat these files as a lab notebook - document as you go, not just at the end.

## Summary Command

When the session is complete, use the `/summary` command to generate an intelligent summary of the entire session. This will create a summary.md file synthesizing all documentation.

## Secure Secrets Handling

Sensitive data is automatically detected and stored securely (macOS Keychain, Windows Credential Manager, or encrypted file):

**Auto-detected patterns:**
- Files: .env, filenames containing key, secret, password, token, credential, auth
- Content: Variables like API_KEY, SECRET_TOKEN, PASSWORD, etc.

**What happens:**
1. Sensitive values are extracted and stored securely
2. The artifact file contains redacted placeholders
3. MANIFEST.json lists which secrets exist (not the values)

**Retrieving secrets:**
```bash
cs -secrets backend                # Check which storage backend is active
cs -secrets list                   # List secrets for current session
cs -secrets get API_KEY            # Get a specific secret value
cs -secrets export                 # Export as environment variables
```

**If you detect sensitive data** that wasn't auto-captured (unusual patterns, embedded credentials, etc.), use cs -secrets directly:
```bash
cs -secrets set <name> <value>     # Store manually
```

## Best Practices

- Document discoveries as you find them - don't wait until the end
- Use artifacts/ for any reusable scripts or configs
- changes.md is updated automatically when files are modified
- Run `/summary` at the end to create a cohesive record
- Never write raw API keys or passwords to artifact files - use cs -secrets
EOF

    # Initialize empty MANIFEST.json
    echo "[]" > "$session_dir/artifacts/MANIFEST.json"

    # Initialize session log
    cat > "$session_dir/logs/session.log" << EOF
Claude Code Session Log
Session: $(basename "$session_dir")
Started: $(date '+%Y-%m-%d %H:%M:%S')
Location: $(hostname):$(pwd)

================================================================================

EOF

    # Initialize sync config with auto-sync enabled by default
    cat > "$session_dir/sync.conf" << EOF
auto_sync=on
EOF
}

# Migrate existing session to latest format
migrate_session() {
    local session_dir="$1"
    local claude_md="$session_dir/CLAUDE.md"

    # Check if CLAUDE.md needs migration (old format has "## Session Structure")
    if [ -f "$claude_md" ] && grep -q "^## Session Structure" "$claude_md"; then
        cat > "$claude_md" << 'EOF'
# Session Documentation Protocol

This is a Claude Code session managed by the cs tool. This session has automatic artifact tracking and documentation support.

## Session Files - READ THESE ON RESUME

When resuming this session, read the following files to restore context:

1. **summary.md** - If exists, read first for previous session overview
2. **README.md** - Session objective, environment, and outcome
3. **discoveries.md** - Findings, observations, and ideas
4. **changes.md** - Modifications and fixes made
5. **artifacts/MANIFEST.json** - List of tracked artifacts

## Artifact Auto-Tracking

Scripts and configuration files you create are **automatically saved to artifacts/**:

- Scripts: .sh, .bash, .zsh, .py, .js, .ts, .rb, .pl
- Configs: .conf, .config, .json, .yaml, .yml, .toml, .ini, .env

When you use the Write tool for these file types, they are automatically redirected to the artifacts/ directory and tracked in MANIFEST.json.

## Documentation Discipline

Update the markdown documentation files throughout the session:

1. **Start of session:** Fill in README.md objective and environment
2. **As you work:** Update discoveries.md with findings and changes.md with modifications
3. **End of session:** Complete the README.md outcome section

Treat these files as a lab notebook - document as you go, not just at the end.

## Summary Command

When the session is complete, use the `/summary` command to generate an intelligent summary of the entire session. This will create a summary.md file synthesizing all documentation.

## Secure Secrets Handling

Sensitive data is automatically detected and stored securely (macOS Keychain, Windows Credential Manager, or encrypted file):

**Auto-detected patterns:**
- Files: .env, filenames containing key, secret, password, token, credential, auth
- Content: Variables like API_KEY, SECRET_TOKEN, PASSWORD, etc.

**What happens:**
1. Sensitive values are extracted and stored securely
2. The artifact file contains redacted placeholders
3. MANIFEST.json lists which secrets exist (not the values)

**Retrieving secrets:**
```bash
cs -secrets backend                # Check which storage backend is active
cs -secrets list                   # List secrets for current session
cs -secrets get API_KEY            # Get a specific secret value
cs -secrets export                 # Export as environment variables
```

**If you detect sensitive data** that wasn't auto-captured (unusual patterns, embedded credentials, etc.), use cs -secrets directly:
```bash
cs -secrets set <name> <value>     # Store manually
```

## Best Practices

- Document discoveries as you find them - don't wait until the end
- Use artifacts/ for any reusable scripts or configs
- changes.md is updated automatically when files are modified
- Run `/summary` at the end to create a cohesive record
- Never write raw API keys or passwords to artifact files - use cs -secrets
EOF
        warn "Migrated CLAUDE.md to latest format"
    fi

    # Migrate sync.conf if missing (for sessions created before auto-sync default)
    local sync_conf="$session_dir/sync.conf"
    if [ ! -f "$sync_conf" ]; then
        cat > "$sync_conf" << EOF
auto_sync=on
EOF
        warn "Added sync.conf with auto-sync enabled"
    fi
}

# Cross-platform helpers
get_short_hostname() {
    hostname | cut -d. -f1
}

get_file_mtime() {
    local file="$1"
    if [[ "$OSTYPE" == darwin* ]]; then
        stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$file" 2>/dev/null || echo "-"
    else
        stat -c "%y" "$file" 2>/dev/null | cut -d. -f1 || echo "-"
    fi
}

# List all sessions
list_sessions() {
    if [ ! -d "$SESSIONS_ROOT" ]; then
        info "No sessions found"
        return 0
    fi

    local sessions=()
    while IFS= read -r -d '' dir; do
        sessions+=("$(basename "$dir")")
    done < <(find "$SESSIONS_ROOT" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)

    if [ ${#sessions[@]} -eq 0 ]; then
        info "No sessions found"
        return 0
    fi

    # Find max session name length for column alignment
    local max_len=7  # minimum "SESSION" header length
    for session in "${sessions[@]}"; do
        if [ ${#session} -gt $max_len ]; then
            max_len=${#session}
        fi
    done

    # Print header
    printf "${YELLOW}%-${max_len}s  %-16s  %s${NC}\n" "SESSION" "CREATED" "MODIFIED"
    printf "%-${max_len}s  %-16s  %s\n" "$(printf '%*s' "$max_len" '' | tr ' ' '-')" "----------------" "----------------"

    # Print sessions
    for session in "${sessions[@]}"; do
        local session_dir="$SESSIONS_ROOT/$session"
        local created="-"
        local modified="-"

        if [ -f "$session_dir/logs/session.log" ]; then
            local started
            started=$(head -4 "$session_dir/logs/session.log" | grep "Started:" | cut -d' ' -f2-)
            if [ -n "$started" ]; then
                created=$(echo "$started" | cut -d':' -f1,2)
            fi
            modified=$(get_file_mtime "$session_dir/logs/session.log")
        fi

        printf "${GREEN}%-${max_len}s${NC}  %-16s  %s\n" "$session" "$created" "$modified"
    done
}

# Remove a session
remove_session() {
    local session_name="$1"

    if [ -z "$session_name" ]; then
        error "Usage: cs -remove <session-name>"
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ ! -d "$session_dir" ]; then
        error "Session not found: $session_name"
    fi

    # Confirm deletion
    read -r -p $'\033[0;31mRemove session '"'$session_name'"$'? [y/N] \033[0m' confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        info "Cancelled"
        return 0
    fi

    rm -rf "$session_dir"
    info "Removed session: $session_name"
}

# Launch Claude Code
launch_claude_code() {
    local session_name="$1"
    local session_dir="$2"
    local is_new="$3"

    # Set environment variables
    export CLAUDE_SESSION_NAME="$session_name"
    export CLAUDE_SESSION_DIR="$session_dir"
    export CLAUDE_ARTIFACT_DIR="$session_dir/artifacts"

    # Status indicator
    local status_icon status_text
    if [ "$is_new" = "true" ]; then
        status_icon="+"
        status_text="new"
    else
        status_icon="↻"
        status_text="resuming"
    fi

    # Count secrets for this session
    local secret_count=0
    if command -v cs-secrets >/dev/null 2>&1; then
        secret_count=$(cs-secrets list 2>/dev/null | grep -c "^  - " 2>/dev/null) || secret_count=0
        # Ensure it's a valid integer
        [[ "$secret_count" =~ ^[0-9]+$ ]] || secret_count=0
    fi

    # Check git remote status
    local remote_display=""
    if [ -d "$session_dir/.git" ]; then
        local remote_url
        remote_url=$(cd "$session_dir" && git remote get-url origin 2>/dev/null || echo "")
        if [ -n "$remote_url" ]; then
            remote_display="${CYAN}⇄${NC} ${DIM}$remote_url${NC}"
        else
            remote_display="${CYAN}⌂${NC} ${DIM}local-only${NC}"
        fi
    fi

    # Display banner
    echo ""
    echo -e "${GREEN}▌${NC} ${BOLD}cs${NC} ${DIM}$VERSION${NC}"
    echo -e "${GREEN}▌${NC} ${WHITE}${BOLD}$session_name${NC} ${DIM}($status_icon $status_text)${NC}"
    echo -e "${GREEN}▌${NC} ${DIM}$session_dir${NC}"
    if [ -n "$remote_display" ]; then
        echo -e "${GREEN}▌${NC} $remote_display"
    fi
    if [ "$secret_count" -gt 0 ]; then
        local secret_word="secret"
        [ "$secret_count" -gt 1 ] && secret_word="secrets"
        echo -e "${GREEN}▌${NC} ${DIM}⚿${NC} ${YELLOW}${BOLD}$secret_count${NC} ${DIM}$secret_word${NC}"
    fi
    if [ -n "$UPDATE_AVAILABLE" ]; then
        echo -e "${YELLOW}▌${NC} ${YELLOW}Update available: $VERSION -> $UPDATE_AVAILABLE${NC} ${DIM}(cs -update)${NC}"
    fi
    echo ""

    cd "$session_dir"

    # For existing sessions, ask if user wants to continue previous conversation
    local continue_flag=""
    if [ "$is_new" = "false" ]; then
        printf "${DIM}Continue previous conversation?${NC} [Y/n] "
        read -r response
        case "$response" in
            [nN]|[nN][oO])
                continue_flag=""
                ;;
            *)
                continue_flag="--continue"
                ;;
        esac
        echo ""
    fi

    # shellcheck disable=SC2086
    exec $CLAUDE_CODE_BIN $continue_flag
}

# Run secrets subcommand
run_secrets() {
    # Find the secrets helper script
    local secrets_script=""
    local script_dir
    script_dir="$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")"

    # Check common locations
    for loc in "$script_dir/cs-secrets" "$HOME/.local/bin/cs-secrets" "/usr/local/bin/cs-secrets"; do
        if [ -x "$loc" ]; then
            secrets_script="$loc"
            break
        fi
    done

    if [ -z "$secrets_script" ]; then
        error "cs-secrets not found. Try reinstalling with: cs -update --force"
    fi

    # Pass all remaining arguments to secrets script
    exec "$secrets_script" "$@"
}

# ============================================================================
# SYNC FUNCTIONS
# ============================================================================

SYNC_CONFIG_FILE="sync.conf"

# Find the secrets helper script
find_secrets_script() {
    local script_dir
    script_dir="$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")"

    for loc in "$script_dir/cs-secrets" "$HOME/.local/bin/cs-secrets" "/usr/local/bin/cs-secrets"; do
        if [ -x "$loc" ]; then
            echo "$loc"
            return 0
        fi
    done
    return 1
}

# Read sync config value
get_sync_config() {
    local session_dir="$1"
    local key="$2"
    local default="${3:-}"
    local config_file="$session_dir/$SYNC_CONFIG_FILE"

    if [ -f "$config_file" ]; then
        local value
        value=$(grep "^${key}=" "$config_file" 2>/dev/null | cut -d= -f2-)
        echo "${value:-$default}"
    else
        echo "$default"
    fi
}

# Write sync config value
set_sync_config() {
    local session_dir="$1"
    local key="$2"
    local value="$3"
    local config_file="$session_dir/$SYNC_CONFIG_FILE"

    if [ -f "$config_file" ]; then
        if grep -q "^${key}=" "$config_file" 2>/dev/null; then
            # Update existing key (cross-platform: write to temp then move)
            local tmp_file="${config_file}.tmp"
            grep -v "^${key}=" "$config_file" > "$tmp_file" || true
            echo "${key}=${value}" >> "$tmp_file"
            mv "$tmp_file" "$config_file"
        else
            echo "${key}=${value}" >> "$config_file"
        fi
    else
        echo "${key}=${value}" > "$config_file"
    fi
}

# Create session .gitignore
create_session_gitignore() {
    local session_dir="$1"
    cat > "$session_dir/.gitignore" << 'GITIGNORE'
# Transient files
*.lock
*.tmp
*.bak

# Archives (large, regenerated from artifacts)
archives/

# OS files
.DS_Store
Thumbs.db

# Editor files
.vscode/
.idea/
*.swp
*.swo
*~
GITIGNORE
}

# Construct remote URL from prefix and session name
construct_remote_url() {
    local session_name="$1"
    local prefix="${CS_SYNC_PREFIX:-}"

    if [ -z "$prefix" ]; then
        return 1
    fi

    # Normalize prefix: ensure it ends with / or : (for git@host:path style)
    if [[ "$prefix" == *"@"* ]] && [[ "$prefix" != *"/" ]] && [[ "$prefix" != *":" ]]; then
        # git@host style without trailing separator - add /
        prefix="${prefix}/"
    elif [[ "$prefix" != *"/" ]] && [[ "$prefix" != *":" ]]; then
        # https:// style without trailing / - add /
        prefix="${prefix}/"
    fi

    echo "${prefix}${session_name}.git"
}

# Add remote to session git repo
sync_remote() {
    local session_name="$1"
    local remote_url="${2:-}"
    local is_local_only=0

    if [ -z "$session_name" ]; then
        error "No session specified. Use: cs <session> -sync remote [url]"
    fi

    # If no URL provided, try to construct from prefix
    if [ -z "$remote_url" ]; then
        if remote_url=$(construct_remote_url "$session_name" 2>/dev/null); then
            info "Using remote: $remote_url"
        else
            # No URL and no prefix - create local-only repo
            is_local_only=1
        fi
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ ! -d "$session_dir" ]; then
        error "Session not found: $session_name"
    fi

    cd "$session_dir" || error "Cannot access session directory"

    # Security notice (only for remote repos)
    if [ $is_local_only -eq 0 ]; then
        echo ""
        echo -e "${DIM}┌─────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${DIM}│${NC} ${YELLOW}${BOLD}SECURITY NOTICE${NC}                                            ${DIM}│${NC}"
        echo -e "${DIM}│${NC}                                                             ${DIM}│${NC}"
        echo -e "${DIM}│${NC} Session data may contain sensitive information.             ${DIM}│${NC}"
        echo -e "${DIM}│${NC} ${WHITE}${BOLD}Use a PRIVATE repository${NC} to protect your data.             ${DIM}│${NC}"
        echo -e "${DIM}│${NC} Secrets are encrypted, but session files are ${RED}not${NC}.          ${DIM}│${NC}"
        echo -e "${DIM}└─────────────────────────────────────────────────────────────┘${NC}"
        echo ""
    fi

    # Check if already a git repo
    if [ -d ".git" ]; then
        warn "Session is already a git repository"

        if [ $is_local_only -eq 1 ]; then
            # Local-only mode - don't add remote
            if git remote get-url origin >/dev/null 2>&1; then
                info "Session already has a remote. Use 'cs -sync remote <url>' to change it."
            else
                info "Session is local-only (no remote configured)"
            fi
        else
            # Remote mode - add or update remote
            if git remote get-url origin >/dev/null 2>&1; then
                git remote set-url origin "$remote_url"
                info "Updated remote origin to: $remote_url"
            else
                git remote add origin "$remote_url"
                info "Added remote origin: $remote_url"
            fi
        fi
        return 0
    fi

    # Create .gitignore
    create_session_gitignore "$session_dir"

    # Initialize git repo
    git init -q

    # Set default branch to main
    git branch -M main

    if [ $is_local_only -eq 1 ]; then
        # Local-only mode
        info "Initialized local git repo for session: $session_name"
        echo ""
        info "This is a local-only repository (no remote)"
        echo ""
        info "Next steps:"
        echo "  cs -sync push          # Commit changes locally"
        echo "  cs -sync auto on       # Enable auto-commit on session end"
        echo ""
        info "To add a remote later:"
        echo "  cs -sync remote <url>  # Add remote and push"
    else
        # Remote mode
        git remote add origin "$remote_url"

        info "Initialized git repo for session: $session_name"
        info "Remote: $remote_url"
        echo ""
        info "Next steps:"
        echo "  cs -sync push          # Push to remote"
        echo "  cs -sync auto on       # Enable auto-sync"

        if [ -z "${CS_SECRETS_PASSWORD:-}" ]; then
            echo ""
            warn "Note: Set CS_SECRETS_PASSWORD for secrets sync across machines"
        fi
    fi
}

# Push session to remote
sync_push() {
    local session_name="$1"

    if [ -z "$session_name" ]; then
        error "No session specified."
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ ! -d "$session_dir/.git" ]; then
        error "Session git repo not found. This shouldn't happen for new sessions."
    fi

    cd "$session_dir" || error "Cannot access session directory"

    # Check if remote exists
    local has_remote=0
    if git remote get-url origin >/dev/null 2>&1; then
        has_remote=1
    fi

    # Export secrets to encrypted file if password is set
    if [ -n "${CS_SECRETS_PASSWORD:-}" ]; then
        local secrets_script
        if secrets_script=$(find_secrets_script); then
            if "$secrets_script" --session "$session_name" export-file 2>/dev/null; then
                info "Exported secrets to secrets.enc"
            fi
        fi
    fi

    # Stage all changes
    git add -A

    # Check if there are changes to commit
    if git diff --cached --quiet; then
        echo "No changes to commit"

        if [ $has_remote -eq 1 ]; then
            # Still try to push in case there are unpushed commits
            if git rev-parse --abbrev-ref '@{upstream}' >/dev/null 2>&1; then
                local ahead
                ahead=$(git rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo "0")
                if [ "$ahead" -gt 0 ]; then
                    git push origin main
                    info "Pushed $ahead commit(s) to remote"
                else
                    echo "Already up to date with remote"
                fi
            else
                # No upstream set, try initial push
                git push -u origin main 2>/dev/null || echo "No commits to push"
            fi
        else
            # Local-only mode
            local total_commits
            total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
            info "Repository is local-only ($total_commits commit(s))"
        fi
        return 0
    fi

    # Commit with timestamp
    local timestamp short_hostname
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    short_hostname=$(get_short_hostname)

    git commit -q -m "Sync: $timestamp ($short_hostname)"

    # Push or inform based on remote status
    if [ $has_remote -eq 1 ]; then
        if git push -u origin main; then
            info "Pushed session to remote"
        else
            error "Push failed. Check your remote configuration."
        fi
    else
        info "Committed locally (no remote configured)"
        local total_commits
        total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
        echo "  Total commits: $total_commits"
        echo ""
        info "To push to a remote, run: cs -sync remote <url>"
    fi
}

# Pull session from remote
sync_pull() {
    local session_name="$1"

    if [ -z "$session_name" ]; then
        error "No session specified."
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ ! -d "$session_dir/.git" ]; then
        error "Session git repo not found. This shouldn't happen for new sessions."
    fi

    cd "$session_dir" || error "Cannot access session directory"

    # Check if remote exists
    if ! git remote get-url origin >/dev/null 2>&1; then
        info "Repository is local-only (no remote to pull from)"
        local total_commits
        total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
        echo "  Total commits: $total_commits"
        echo ""
        info "To add a remote, run: cs -sync remote <url>"
        return 0
    fi

    # Stash any local changes
    local had_changes=0
    if ! git diff --quiet || ! git diff --cached --quiet; then
        git stash -q
        had_changes=1
    fi

    # Pull with rebase to avoid merge commits
    if git pull --rebase origin main 2>/dev/null; then
        info "Pulled latest changes"
    else
        warn "Pull failed - may need manual resolution"
        if [ $had_changes -eq 1 ]; then
            git stash pop -q 2>/dev/null || true
        fi
        return 1
    fi

    # Restore stashed changes
    if [ $had_changes -eq 1 ]; then
        if ! git stash pop -q 2>/dev/null; then
            warn "Local changes conflicted - saved in git stash"
        fi
    fi

    # Import secrets from encrypted file if it exists and password is set
    local secrets_file="$session_dir/secrets.enc"
    if [ -f "$secrets_file" ] && [ -n "${CS_SECRETS_PASSWORD:-}" ]; then
        local secrets_script
        if secrets_script=$(find_secrets_script); then
            if "$secrets_script" --session "$session_name" import-file 2>/dev/null; then
                info "Imported secrets from secrets.enc"
            fi
        fi
    fi

    info "Session synced"
}

# Show sync status
sync_status() {
    local session_name="$1"

    if [ -z "$session_name" ]; then
        error "No session specified."
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    echo -e "${BOLD}Session:${NC} $session_name"
    echo -e "${BOLD}Path:${NC} $session_dir"
    echo ""

    if [ ! -d "$session_dir/.git" ]; then
        echo -e "${YELLOW}Git not initialized${NC} - This shouldn't happen for new sessions"
        return 0
    fi

    cd "$session_dir" || error "Cannot access session directory"

    local remote
    remote=$(git remote get-url origin 2>/dev/null || echo "none")
    echo -e "${BOLD}Remote:${NC} $remote"

    local branch
    branch=$(git branch --show-current 2>/dev/null || echo "unknown")
    echo -e "${BOLD}Branch:${NC} $branch"

    local auto_sync
    auto_sync=$(get_sync_config "$session_dir" "auto_sync" "off")
    echo -e "${BOLD}Auto-sync:${NC} $auto_sync"

    local secrets_backend script_dir
    script_dir="$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")"
    secrets_backend=$(CLAUDE_SESSION_NAME="$session_name" "$script_dir/cs-secrets" backend 2>/dev/null | head -1 | sed 's/Storage backend: //')
    echo -e "${BOLD}Secrets:${NC} $secrets_backend"

    echo ""

    # Show local changes status
    local changes
    changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$changes" -gt 0 ]; then
        echo -e "${YELLOW}$changes uncommitted change(s)${NC}"
    else
        echo -e "${GREEN}No local changes${NC}"
    fi

    # Check if remote exists
    if [ "$remote" = "none" ]; then
        # Local-only mode
        local total_commits
        total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
        echo -e "${CYAN}Local-only repository ($total_commits commit(s))${NC}"
        echo ""
        info "To add a remote, run: cs $session_name -sync remote <url>"
    else
        # Remote mode - check remote status
        # Check remote status (fetch quietly)
        git fetch -q origin 2>/dev/null || true

        # Check if upstream is configured
        if ! git rev-parse --abbrev-ref '@{upstream}' >/dev/null 2>&1; then
            echo -e "${YELLOW}Warning: No upstream tracking configured for branch '$branch'${NC}"
            echo -e "${YELLOW}Run: git branch --set-upstream-to=origin/$branch $branch${NC}"
        else
            local ahead behind
            ahead=$(git rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo "0")
            behind=$(git rev-list --count 'HEAD..@{upstream}' 2>/dev/null || echo "0")

            if [ "$ahead" -gt 0 ]; then
                echo -e "${CYAN}$ahead commit(s) ahead of remote${NC}"
            fi
            if [ "$behind" -gt 0 ]; then
                echo -e "${CYAN}$behind commit(s) behind remote${NC}"
            fi
            if [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ]; then
                echo -e "${GREEN}Up to date with remote${NC}"
            fi
        fi
    fi

    # Secrets status
    echo ""
    if [ -f "$session_dir/secrets.enc" ]; then
        local enc_time
        enc_time=$(get_file_mtime "$session_dir/secrets.enc")
        echo -e "${BOLD}Secrets file:${NC} secrets.enc (modified: $enc_time)"
    else
        echo -e "${BOLD}Secrets file:${NC} not exported"
    fi
}

# Toggle auto-sync
sync_auto() {
    local session_name="$1"
    local setting="$2"

    if [ -z "$session_name" ]; then
        error "No session specified."
    fi

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ ! -d "$session_dir" ]; then
        error "Session not found: $session_name"
    fi

    if [ -z "$setting" ]; then
        # Show current setting
        local current
        current=$(get_sync_config "$session_dir" "auto_sync" "off")
        echo "Auto-sync: $current"
        return 0
    fi

    case "$setting" in
        on|off)
            set_sync_config "$session_dir" "auto_sync" "$setting"
            info "Auto-sync set to: $setting"
            ;;
        *)
            error "Usage: cs -sync auto [on|off]"
            ;;
    esac
}

# Check if argument looks like a URL
is_remote_url() {
    local arg="$1"
    # URLs contain :// or have @ followed by :
    [[ "$arg" == *"://"* ]] || [[ "$arg" == *"@"*":"* ]]
}

# Clone session from remote
sync_clone() {
    local first_arg="$1"
    local second_arg="${2:-}"
    local remote_url=""
    local session_name=""

    if [ -z "$first_arg" ]; then
        error "Usage: cs -sync clone <session-name|remote-url> [session-name]"
    fi

    # Detect if first arg is URL or session name
    if is_remote_url "$first_arg"; then
        # First arg is a URL
        remote_url="$first_arg"
        session_name="${second_arg:-$(basename "$remote_url" .git)}"
    else
        # First arg is a session name - construct URL from prefix
        session_name="$first_arg"
        if remote_url=$(construct_remote_url "$session_name"); then
            info "Using remote: $remote_url"
        else
            error "No URL provided. Either specify a URL or set CS_SYNC_PREFIX."
        fi
    fi

    validate_session_name "$session_name"

    local session_dir="$SESSIONS_ROOT/$session_name"

    if [ -d "$session_dir" ]; then
        error "Session already exists: $session_name"
    fi

    # Clone the repo
    info "Cloning session: $session_name"
    if ! git clone "$remote_url" "$session_dir"; then
        error "Clone failed. Check the remote URL."
    fi

    info "Cloned session to: $session_dir"

    # Import secrets if available
    local secrets_file="$session_dir/secrets.enc"
    if [ -f "$secrets_file" ]; then
        if [ -z "${CS_SECRETS_PASSWORD:-}" ]; then
            warn "secrets.enc found but CS_SECRETS_PASSWORD not set"
            warn "Set CS_SECRETS_PASSWORD and run: cs -secrets --session $session_name import-file"
        else
            local secrets_script
            if secrets_script=$(find_secrets_script); then
                "$secrets_script" --session "$session_name" import-file 2>/dev/null && \
                    info "Imported secrets"
            fi
        fi
    fi

    echo ""
    info "Start session with: cs $session_name"
}

# Uninstall cs and all components
run_uninstall() {
    local install_dir="$HOME/.local/bin"
    local hooks_dir="$HOME/.claude/hooks"
    local commands_dir="$HOME/.claude/commands"
    local skills_dir="$HOME/.claude/skills"
    local settings_file="$HOME/.claude/settings.json"
    local bash_completion_dir="$HOME/.bash_completion.d"
    local zsh_completion_dir="$HOME/.zsh/completions"

    warn "This will uninstall cs and all its components:"
    echo "  - $install_dir/cs, $install_dir/cs-secrets"
    echo "  - Hooks in $hooks_dir/"
    echo "  - Commands in $commands_dir/"
    echo "  - Skills in $skills_dir/"
    echo "  - Shell completions"
    echo "  - Hook entries in $settings_file"
    echo ""
    read -p "Continue with uninstall? [y/N] " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Uninstall cancelled."
        return 0
    fi

    echo ""
    info "Uninstalling cs..."
    echo ""

    # Remove binaries
    if [ -f "$install_dir/cs" ]; then
        rm "$install_dir/cs"
        info "Removed $install_dir/cs"
    fi

    if [ -f "$install_dir/cs-secrets" ]; then
        rm "$install_dir/cs-secrets"
        info "Removed $install_dir/cs-secrets"
    fi

    # Remove hooks
    for hook in session-start.sh artifact-tracker.sh changes-tracker.sh discoveries-reminder.sh session-end.sh; do
        if [ -f "$hooks_dir/$hook" ]; then
            rm "$hooks_dir/$hook"
            info "Removed $hooks_dir/$hook"
        fi
    done

    # Remove commands
    if [ -f "$commands_dir/summary.md" ]; then
        rm "$commands_dir/summary.md"
        info "Removed $commands_dir/summary.md"
    fi

    # Remove skills
    if [ -d "$skills_dir/store-secret" ]; then
        rm -rf "$skills_dir/store-secret"
        info "Removed $skills_dir/store-secret/"
    fi

    # Remove shell completions
    if [ -f "$bash_completion_dir/cs.bash" ]; then
        rm "$bash_completion_dir/cs.bash"
        info "Removed $bash_completion_dir/cs.bash"
    fi

    if [ -f "$zsh_completion_dir/_cs" ]; then
        rm "$zsh_completion_dir/_cs"
        info "Removed $zsh_completion_dir/_cs"
    fi

    # Clean up settings.json (remove cs hooks, preserve others)
    if [ -f "$settings_file" ] && command -v jq >/dev/null 2>&1; then
        local session_start_path="$hooks_dir/session-start.sh"
        local artifact_tracker_path="$hooks_dir/artifact-tracker.sh"
        local changes_tracker_path="$hooks_dir/changes-tracker.sh"
        local discoveries_reminder_path="$hooks_dir/discoveries-reminder.sh"
        local session_end_path="$hooks_dir/session-end.sh"

        local settings
        settings=$(cat "$settings_file")

        # Remove our SessionStart hook
        settings=$(echo "$settings" | jq --arg path "$session_start_path" '
            if .hooks.SessionStart then
                .hooks.SessionStart = [.hooks.SessionStart[] | select(.hooks | all(.command != $path))]
            else . end
        ')

        # Remove our PreToolUse Write hook
        settings=$(echo "$settings" | jq --arg path "$artifact_tracker_path" '
            if .hooks.PreToolUse then
                .hooks.PreToolUse = [.hooks.PreToolUse[] | select(
                    (.matcher == "Write" and (.hooks | any(.command == $path))) | not
                )]
            else . end
        ')

        # Remove our PostToolUse changes tracker hook
        settings=$(echo "$settings" | jq --arg path "$changes_tracker_path" '
            if .hooks.PostToolUse then
                .hooks.PostToolUse = [.hooks.PostToolUse[] | select(.hooks | all(.command != $path))]
            else . end
        ')

        # Remove our Stop discoveries reminder hook
        settings=$(echo "$settings" | jq --arg path "$discoveries_reminder_path" '
            if .hooks.Stop then
                .hooks.Stop = [.hooks.Stop[] | select(.hooks | all(.command != $path))]
            else . end
        ')

        # Remove our SessionEnd hook
        settings=$(echo "$settings" | jq --arg path "$session_end_path" '
            if .hooks.SessionEnd then
                .hooks.SessionEnd = [.hooks.SessionEnd[] | select(.hooks | all(.command != $path))]
            else . end
        ')

        # Clean up empty hook arrays
        settings=$(echo "$settings" | jq '
            if .hooks then
                .hooks |= with_entries(select(.value | length > 0))
                | if .hooks == {} then del(.hooks) else . end
            else . end
        ')

        echo "$settings" > "$settings_file"
        info "Cleaned up $settings_file"
    elif [ -f "$settings_file" ]; then
        warn "jq not found - cannot clean up $settings_file automatically"
        warn "Manually remove cs hook entries from $settings_file"
    fi

    # Ask about secrets in keychain
    if [ -d "$SESSIONS_ROOT" ]; then
        local sessions
        sessions=$(ls -1 "$SESSIONS_ROOT" 2>/dev/null | grep -v "^INDEX.md$" || true)

        if [ -n "$sessions" ]; then
            echo ""
            warn "Secrets may exist in OS keychain for these sessions:"
            echo "$sessions" | while read -r s; do
                echo "  - $s"
            done
            echo ""
            read -p "Delete secrets from keychain? [y/N] " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                # Find cs-secrets script
                local secrets_script=""
                for loc in "$install_dir/cs-secrets" "/usr/local/bin/cs-secrets"; do
                    if [ -x "$loc" ]; then
                        secrets_script="$loc"
                        break
                    fi
                done

                if [ -n "$secrets_script" ]; then
                    echo "$sessions" | while read -r s; do
                        "$secrets_script" --session "$s" purge 2>/dev/null || true
                    done
                else
                    warn "cs-secrets not found - cannot purge secrets automatically"
                fi
            else
                info "Kept secrets in keychain"
            fi
        fi
    fi

    # Ask about session data
    if [ -d "$SESSIONS_ROOT" ]; then
        echo ""
        warn "Session data exists at $SESSIONS_ROOT"
        read -p "Delete session data? This cannot be undone. [y/N] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            rm -rf "$SESSIONS_ROOT"
            info "Removed $SESSIONS_ROOT"
        else
            info "Kept $SESSIONS_ROOT"
        fi
    fi

    echo ""
    info "Uninstall complete!"
}

# Main sync command router
run_sync() {
    local subcommand="${1:-}"
    shift 2>/dev/null || true

    # Determine session name from environment or --session flag
    local session_name="${CLAUDE_SESSION_NAME:-}"

    # Parse --session flag if present
    while [ $# -gt 0 ]; do
        case "$1" in
            -s|--session)
                session_name="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    case "$subcommand" in
        remote)
            sync_remote "$session_name" "${1:-}"
            ;;
        push)
            sync_push "$session_name"
            ;;
        pull)
            sync_pull "$session_name"
            ;;
        status|st)
            sync_status "$session_name"
            ;;
        auto)
            sync_auto "$session_name" "${1:-}"
            ;;
        clone)
            sync_clone "${1:-}" "${2:-}"
            ;;
        "")
            # Default to status if in a session, otherwise show help
            if [ -n "$session_name" ]; then
                sync_status "$session_name"
            else
                error "Usage: cs -sync <init|push|pull|status|auto|clone>"
            fi
            ;;
        *)
            error "Unknown sync command: $subcommand. Use: init, push, pull, status, auto, clone"
            ;;
    esac
}

# Main function
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    local cmd="$1"

    # Handle subcommands (with - prefix)
    case "$cmd" in
        -h|-help|--help)
            show_help
            return 0
            ;;
        -v|-version|--version)
            echo "cs $VERSION"
            return 0
            ;;
        -list|-ls)
            list_sessions
            return 0
            ;;
        -remove|-rm)
            remove_session "${2:-}"
            return 0
            ;;
        -secrets)
            shift
            run_secrets "$@"
            return 0
            ;;
        -sync|-s)
            shift
            run_sync "$@"
            return 0
            ;;
        -uninstall)
            run_uninstall
            return 0
            ;;
        -update)
            local update_arg="${2:-}"
            case "$update_arg" in
                --check|-c)
                    check_update
                    ;;
                --force|-f)
                    do_update "true"
                    ;;
                "")
                    do_update
                    ;;
                *)
                    error "Unknown option: $update_arg. Use 'cs -update [--check|--force]'"
                    ;;
            esac
            return 0
            ;;
        -*)
            error "Unknown command: $cmd. Run 'cs -help' for usage."
            ;;
    esac

    local session_name="$cmd"

    # Validate inputs
    validate_session_name "$session_name"

    # Check for session subcommands: cs <session> -sync, cs <session> -secrets
    if [ $# -gt 1 ]; then
        local subcmd="$2"
        shift 2  # Remove session name and subcommand

        case "$subcmd" in
            -sync|-s)
                # Set up session context for sync command
                export CLAUDE_SESSION_NAME="$session_name"
                export CLAUDE_SESSION_DIR="$SESSIONS_ROOT/$session_name"
                export CLAUDE_ARTIFACT_DIR="$SESSIONS_ROOT/$session_name/artifacts"
                run_sync "$@"
                return 0
                ;;
            -secrets)
                # Set up session context for secrets command
                export CLAUDE_SESSION_NAME="$session_name"
                export CLAUDE_SESSION_DIR="$SESSIONS_ROOT/$session_name"
                export CLAUDE_ARTIFACT_DIR="$SESSIONS_ROOT/$session_name/artifacts"
                run_secrets "$@"
                return 0
                ;;
            *)
                error "Unknown session command: $subcmd. Use -sync or -secrets."
                ;;
        esac
    fi

    check_dependencies

    # Check for updates (non-blocking)
    check_update_notify

    # Define paths
    local session_dir="$SESSIONS_ROOT/$session_name"
    local is_new="false"

    # Create session structure if needed
    if [ ! -d "$session_dir" ]; then
        is_new="true"
        create_session_structure "$session_dir"

        # Initialize local git repo by default
        (
            cd "$session_dir" || exit 0
            create_session_gitignore "$session_dir"
            git init -q 2>/dev/null || true
            git branch -M main 2>/dev/null || true
            git add -A 2>/dev/null || true
            git commit -q -m "Initial session structure" 2>/dev/null || true
        )
    else
        migrate_session "$session_dir"
    fi

    # Launch Claude Code
    launch_claude_code "$session_name" "$session_dir" "$is_new"
}

main "$@"
