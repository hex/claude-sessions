#!/usr/bin/env bash
# ABOUTME: Cross-platform secure secrets management for cs sessions
# ABOUTME: Supports macOS Keychain, Windows Credential Manager, and encrypted file fallback

set -euo pipefail

SCRIPT_NAME=$(basename "$0")

# Configuration
SECRETS_DIR="${HOME}/.cs-secrets"
SALT_FILE="${SECRETS_DIR}/.salt"

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
    set, store <name> [val] Store a secret (prompts if value not provided)
    get <name>              Retrieve a secret value
    list, ls                List all secrets for current session
    delete, rm <name>       Delete a secret
    export                  Export secrets as environment variables (eval-able)
    migrate [--redact]      Migrate plaintext secrets from artifact files
    backend                 Show which storage backend is being used

Options:
    -s, --session <name>    Specify session (default: \$CLAUDE_SESSION_NAME)
    -h, --help              Show this help message

Backends (auto-detected):
    keychain    macOS Keychain (most secure on macOS)
    credential  Windows Credential Manager via PowerShell
    encrypted   OpenSSL-encrypted file (cross-platform fallback)

Environment:
    CS_SECRETS_PASSWORD     Master password for encrypted backend
    CLAUDE_SESSION_NAME     Current session name

Examples:
    $SCRIPT_NAME store api_key              # Prompts for value
    $SCRIPT_NAME store api_key "sk-abc123"  # Store directly
    $SCRIPT_NAME get api_key                # Retrieve value
    $SCRIPT_NAME list                       # List all secrets
    eval "\$($SCRIPT_NAME export)"          # Load secrets as env vars
EOF
    exit 0
}

error() {
    echo "Error: $1" >&2
    exit 1
}

# Detect operating system and available backend
detect_backend() {
    case "$OSTYPE" in
        darwin*)
            # macOS - use Keychain
            if command -v security >/dev/null 2>&1; then
                echo "keychain"
                return
            fi
            ;;
        msys*|cygwin*|mingw*)
            # Windows (Git Bash, MSYS2, Cygwin)
            if command -v powershell.exe >/dev/null 2>&1; then
                # Check if SecretManagement module is available
                if powershell.exe -NoProfile -Command "Get-Module -ListAvailable -Name Microsoft.PowerShell.SecretManagement" 2>/dev/null | grep -q "SecretManagement"; then
                    echo "credential"
                    return
                fi
            fi
            ;;
    esac

    # Fallback to encrypted file (works everywhere with OpenSSL)
    if command -v openssl >/dev/null 2>&1; then
        echo "encrypted"
        return
    fi

    error "No supported secret storage backend found. Install OpenSSL for encrypted file support."
}

BACKEND=$(detect_backend)

# ============================================================================
# KEYCHAIN BACKEND (macOS)
# ============================================================================

keychain_service() {
    local session="$1"
    local name="$2"
    echo "cs:${session}:${name}"
}

keychain_store() {
    local session="$1"
    local name="$2"
    local value="$3"
    local service
    service=$(keychain_service "$session" "$name")

    security add-generic-password -a "$USER" -s "$service" -w "$value" -U 2>/dev/null || \
        error "Failed to store secret in Keychain"
    echo "Stored secret: $name"
}

keychain_get() {
    local session="$1"
    local name="$2"
    local service
    service=$(keychain_service "$session" "$name")

    local value
    if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
        echo "$value"
    else
        error "Secret not found: $name"
    fi
}

keychain_list() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$secrets" | while read -r name; do
            echo "  - $name"
        done
    fi
}

keychain_delete() {
    local session="$1"
    local name="$2"
    local service
    service=$(keychain_service "$session" "$name")

    if security delete-generic-password -a "$USER" -s "$service" >/dev/null 2>&1; then
        echo "Deleted secret: $name"
    else
        error "Secret not found or could not be deleted: $name"
    fi
}

keychain_export() {
    local session="$1"
    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -n "$secrets" ]]; then
        echo "$secrets" | while read -r name; do
            local service
            service=$(keychain_service "$session" "$name")
            local value
            if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
                local var_name
                var_name=$(echo "$name" | tr '[:lower:]-' '[:upper:]_')
                printf 'export %s=%q\n' "$var_name" "$value"
            fi
        done
    fi
}

# ============================================================================
# ENCRYPTED FILE BACKEND (Cross-platform)
# ============================================================================

get_encryption_password() {
    # Priority:
    # 1. Environment variable
    # 2. Derived from machine characteristics + salt

    if [[ -n "${CS_SECRETS_PASSWORD:-}" ]]; then
        echo "$CS_SECRETS_PASSWORD"
        return
    fi

    # Ensure secrets directory and salt exist
    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    if [[ ! -f "$SALT_FILE" ]]; then
        # Generate random salt on first use
        openssl rand -hex 32 > "$SALT_FILE"
        chmod 600 "$SALT_FILE"
    fi

    local salt
    salt=$(cat "$SALT_FILE")

    # Derive password from user + hostname + salt
    # This provides machine-specific encryption
    local machine_id="${USER}@$(hostname)"
    echo -n "${machine_id}${salt}" | openssl dgst -sha256 -r | cut -d' ' -f1
}

encrypted_file_path() {
    local session="$1"
    echo "${SECRETS_DIR}/${session}.enc"
}

encrypted_read_store() {
    local session="$1"
    local file
    file=$(encrypted_file_path "$session")

    if [[ ! -f "$file" ]]; then
        echo "{}"
        return
    fi

    local password
    password=$(get_encryption_password)

    openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 -in "$file" -pass "pass:$password" 2>/dev/null || echo "{}"
}

encrypted_write_store() {
    local session="$1"
    local data="$2"
    local file
    file=$(encrypted_file_path "$session")

    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    local password
    password=$(get_encryption_password)

    echo "$data" | openssl enc -aes-256-cbc -e -pbkdf2 -iter 100000 -out "$file" -pass "pass:$password"
    chmod 600 "$file"
}

encrypted_store() {
    local session="$1"
    local name="$2"
    local value="$3"

    local store
    store=$(encrypted_read_store "$session")

    local updated
    updated=$(echo "$store" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')

    encrypted_write_store "$session" "$updated"
    echo "Stored secret: $name"
}

encrypted_get() {
    local session="$1"
    local name="$2"

    local store
    store=$(encrypted_read_store "$session")

    local value
    value=$(echo "$store" | jq -r --arg name "$name" '.[$name] // empty')

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

encrypted_list() {
    local session="$1"

    local store
    store=$(encrypted_read_store "$session")

    local keys
    keys=$(echo "$store" | jq -r 'keys[]' 2>/dev/null || true)

    if [[ -z "$keys" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$keys" | while read -r name; do
            echo "  - $name"
        done
    fi
}

encrypted_delete() {
    local session="$1"
    local name="$2"

    local store
    store=$(encrypted_read_store "$session")

    # Check if key exists
    if ! echo "$store" | jq -e --arg name "$name" 'has($name)' >/dev/null 2>&1; then
        error "Secret not found: $name"
    fi

    local updated
    updated=$(echo "$store" | jq --arg name "$name" 'del(.[$name])')

    encrypted_write_store "$session" "$updated"
    echo "Deleted secret: $name"
}

encrypted_export() {
    local session="$1"

    local store
    store=$(encrypted_read_store "$session")

    echo "$store" | jq -r 'to_entries[] | "export " + (.key | gsub("-"; "_") | ascii_upcase) + "=" + (.value | @sh)' 2>/dev/null || true
}

# ============================================================================
# WINDOWS CREDENTIAL MANAGER BACKEND (PowerShell)
# ============================================================================

credential_store() {
    local session="$1"
    local name="$2"
    local value="$3"
    local target="cs:${session}:${name}"

    powershell.exe -NoProfile -Command "
        \$secureValue = ConvertTo-SecureString '$value' -AsPlainText -Force
        \$cred = New-Object System.Management.Automation.PSCredential('$USER', \$secureValue)
        Set-Secret -Name '$target' -SecureStringSecret \$cred.Password -Vault 'cs-secrets' -ErrorAction SilentlyContinue
        if (-not \$?) {
            # Vault doesn't exist, create it with default store
            Register-SecretVault -Name 'cs-secrets' -ModuleName 'Microsoft.PowerShell.SecretStore' -DefaultVault
            Set-Secret -Name '$target' -SecureStringSecret \$cred.Password -Vault 'cs-secrets'
        }
    " 2>/dev/null || error "Failed to store secret"
    echo "Stored secret: $name"
}

credential_get() {
    local session="$1"
    local name="$2"
    local target="cs:${session}:${name}"

    local value
    value=$(powershell.exe -NoProfile -Command "
        \$secret = Get-Secret -Name '$target' -Vault 'cs-secrets' -AsPlainText -ErrorAction SilentlyContinue
        if (\$secret) { Write-Output \$secret }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

credential_list() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object { \$_.Name -replace '^${prefix}', '' }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$secrets" | while read -r name; do
            [[ -n "$name" ]] && echo "  - $name"
        done
    fi
}

credential_delete() {
    local session="$1"
    local name="$2"
    local target="cs:${session}:${name}"

    if powershell.exe -NoProfile -Command "Remove-Secret -Name '$target' -Vault 'cs-secrets'" 2>/dev/null; then
        echo "Deleted secret: $name"
    else
        error "Secret not found or could not be deleted: $name"
    fi
}

credential_export() {
    local session="$1"
    local prefix="cs:${session}:"

    powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object {
            \$name = \$_.Name -replace '^${prefix}', ''
            \$value = Get-Secret -Name \$_.Name -Vault 'cs-secrets' -AsPlainText
            \$envName = (\$name -replace '-', '_').ToUpper()
            Write-Output \"export \$envName='\$value'\"
        }
    " 2>/dev/null | tr -d '\r'
}

# ============================================================================
# BACKEND DISPATCH
# ============================================================================

backend_store() {
    case "$BACKEND" in
        keychain)   keychain_store "$@" ;;
        credential) credential_store "$@" ;;
        encrypted)  encrypted_store "$@" ;;
    esac
}

backend_get() {
    case "$BACKEND" in
        keychain)   keychain_get "$@" ;;
        credential) credential_get "$@" ;;
        encrypted)  encrypted_get "$@" ;;
    esac
}

backend_list() {
    case "$BACKEND" in
        keychain)   keychain_list "$@" ;;
        credential) credential_list "$@" ;;
        encrypted)  encrypted_list "$@" ;;
    esac
}

backend_delete() {
    case "$BACKEND" in
        keychain)   keychain_delete "$@" ;;
        credential) credential_delete "$@" ;;
        encrypted)  encrypted_delete "$@" ;;
    esac
}

backend_export() {
    case "$BACKEND" in
        keychain)   keychain_export "$@" ;;
        credential) credential_export "$@" ;;
        encrypted)  encrypted_export "$@" ;;
    esac
}

# ============================================================================
# MIGRATE COMMAND
# ============================================================================

# Sensitive patterns to detect in key names (same as artifact-tracker.sh)
SENSITIVE_PATTERNS=("key" "secret" "password" "token" "credential" "auth" "apikey" "api_key")

is_sensitive_key() {
    local key="$1"
    local key_lower
    key_lower=$(echo "$key" | tr '[:upper:]' '[:lower:]')

    for pattern in "${SENSITIVE_PATTERNS[@]}"; do
        if [[ "$key_lower" == *"$pattern"* ]]; then
            return 0
        fi
    done
    return 1
}

migrate_secrets() {
    local session="$1"
    local do_redact="$2"
    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    local session_dir="$sessions_root/$session"
    local artifacts_dir="$session_dir/artifacts"

    if [[ ! -d "$artifacts_dir" ]]; then
        echo "No artifacts directory found for session: $session"
        echo "Path checked: $artifacts_dir"
        return 0
    fi

    local migrated=0
    local files_updated=0

    echo "Scanning artifacts for plaintext secrets..."
    echo ""

    # Process each file in artifacts (excluding MANIFEST.json)
    while IFS= read -r -d '' file; do
        local filename
        filename=$(basename "$file")
        [[ "$filename" == "MANIFEST.json" ]] && continue

        local content
        content=$(cat "$file")
        local new_content="$content"
        local file_had_secrets=0

        # Process each line looking for KEY=value or KEY: value patterns
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// /}" ]] && continue

            local key=""
            local value=""

            # Pattern: KEY=value or KEY="value" or KEY='value'
            if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*[\"\']?([^\"\']+)[\"\']?[[:space:]]*$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
            # Pattern: KEY: value
            elif [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*:[[:space:]]+(.+)[[:space:]]*$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
            fi

            [[ -z "$key" ]] && continue
            [[ -z "$value" ]] && continue

            # Skip if already redacted
            [[ "$value" == *"[REDACTED"* ]] && continue

            # Check if this looks like a sensitive key
            if is_sensitive_key "$key"; then
                # Store the secret
                backend_store "$session" "$key" "$value" >/dev/null
                echo "  Migrated: $key (from $filename)"
                ((migrated++))
                file_had_secrets=1

                # Prepare redacted version if requested
                if [[ "$do_redact" -eq 1 ]]; then
                    local redacted_value="[REDACTED: stored in keychain as $key]"
                    # Escape special characters for sed
                    local escaped_value
                    escaped_value=$(printf '%s\n' "$value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    local escaped_redacted
                    escaped_redacted=$(printf '%s\n' "$redacted_value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    new_content=$(echo "$new_content" | sed "s|$escaped_value|$escaped_redacted|g")
                fi
            fi
        done <<< "$content"

        # Write redacted content back if we made changes
        if [[ "$do_redact" -eq 1 && "$file_had_secrets" -eq 1 ]]; then
            echo "$new_content" > "$file"
            ((files_updated++))
        fi

    done < <(find "$artifacts_dir" -type f -print0)

    echo ""
    if [[ $migrated -eq 0 ]]; then
        echo "No plaintext secrets found to migrate."
    else
        echo "Migrated $migrated secret(s) to secure storage."
        if [[ "$do_redact" -eq 1 ]]; then
            echo "Updated $files_updated file(s) with redacted values."
        else
            echo ""
            echo "Tip: Run with --redact to replace plaintext values with redaction markers."
        fi
    fi
}

# ============================================================================
# MAIN
# ============================================================================

# Parse arguments
SESSION_NAME="${CLAUDE_SESSION_NAME:-}"
COMMAND=""
SECRET_NAME=""
SECRET_VALUE=""
DO_REDACT=0

while [[ $# -gt 0 ]]; do
    case "$1" in
        -s|--session)
            SESSION_NAME="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        set|store|get|list|ls|delete|rm|export|migrate|backend)
            COMMAND="$1"
            shift
            ;;
        --redact)
            DO_REDACT=1
            shift
            ;;
        *)
            if [[ -z "$SECRET_NAME" ]]; then
                SECRET_NAME="$1"
            elif [[ -z "$SECRET_VALUE" ]]; then
                SECRET_VALUE="$1"
            fi
            shift
            ;;
    esac
done

# Handle backend command specially
if [[ "$COMMAND" == "backend" ]]; then
    echo "Storage backend: $BACKEND"
    case "$BACKEND" in
        keychain)   echo "Using macOS Keychain" ;;
        credential) echo "Using Windows Credential Manager (PowerShell SecretManagement)" ;;
        encrypted)  echo "Using OpenSSL-encrypted file (~/.cs-secrets/)" ;;
    esac
    exit 0
fi

# Validate session
if [[ -z "$SESSION_NAME" && -n "$COMMAND" ]]; then
    error "No session specified. Set CLAUDE_SESSION_NAME or use --session"
fi

# Execute command
case "$COMMAND" in
    store|set)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        if [[ -z "$SECRET_VALUE" ]]; then
            printf "Enter value for %s: " "$SECRET_NAME"
            read -r SECRET_VALUE
        fi
        [[ -z "$SECRET_VALUE" ]] && error "Secret value cannot be empty"
        backend_store "$SESSION_NAME" "$SECRET_NAME" "$SECRET_VALUE"
        ;;
    get)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        backend_get "$SESSION_NAME" "$SECRET_NAME"
        ;;
    list|ls)
        backend_list "$SESSION_NAME"
        ;;
    delete|rm)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        backend_delete "$SESSION_NAME" "$SECRET_NAME"
        ;;
    export)
        backend_export "$SESSION_NAME"
        ;;
    migrate)
        migrate_secrets "$SESSION_NAME" "$DO_REDACT"
        ;;
    "")
        usage
        ;;
    *)
        error "Unknown command: $COMMAND"
        ;;
esac
