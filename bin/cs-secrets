#!/usr/bin/env bash
# ABOUTME: Cross-platform secure secrets management for cs sessions
# ABOUTME: Supports Bitwarden Secrets Manager, macOS Keychain, Windows Credential Manager, and encrypted file fallback

set -euo pipefail

SCRIPT_NAME=$(basename "$0")

# Configuration
SECRETS_DIR="${HOME}/.cs-secrets"
SALT_FILE="${SECRETS_DIR}/.salt"

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
    set, store <name> [val] Store a secret (prompts if value not provided)
    get <name>              Retrieve a secret value
    list, ls                List all secrets for current session
    delete, rm <name>       Delete a secret
    purge                   Delete ALL secrets for current session
    export                  Export secrets as environment variables (eval-able)
    export-file [FILE]      Export secrets to encrypted file for sync (default: secrets.enc)
    import-file [FILE]      Import secrets from encrypted file (default: secrets.enc)
    migrate [--redact]      Migrate plaintext secrets from artifact files
    migrate-backend <to>    Migrate secrets to different backend [--from <backend>] [--delete-source]
    backend                 Show which storage backend is being used

Options:
    -s, --session <name>    Specify session (default: \$CLAUDE_SESSION_NAME)
    -h, --help              Show this help message

Backends (auto-detected, in priority order):
    bitwarden   Bitwarden Secrets Manager (cross-machine sync)
    keychain    macOS Keychain (most secure on macOS)
    credential  Windows Credential Manager via PowerShell
    encrypted   OpenSSL-encrypted file (cross-platform fallback)

Environment:
    CS_SECRETS_BACKEND      Override backend (bitwarden, keychain, credential, encrypted)
    CS_SECRETS_PASSWORD     Master password for encrypted backend
    CLAUDE_SESSION_NAME     Current session name

Examples:
    $SCRIPT_NAME store api_key              # Prompts for value
    $SCRIPT_NAME store api_key "sk-abc123"  # Store directly
    $SCRIPT_NAME get api_key                # Retrieve value
    $SCRIPT_NAME list                       # List all secrets
    eval "\$($SCRIPT_NAME export)"          # Load secrets as env vars
EOF
    exit 0
}

error() {
    echo "Error: $1" >&2
    exit 1
}

# ============================================================================
# BITWARDEN HELPERS
# ============================================================================

# Get Bitwarden project name for a session
bws_project_name() {
    local session="$1"
    echo "cs-${session}"
}

# Find project ID by name, returns empty if not found
bws_find_project_id() {
    local name="$1"
    local list_output
    list_output=$(bws project list 2>/dev/null) || return 0
    echo "$list_output" | jq -r ".[] | select(.name==\"$name\") | .id" 2>/dev/null || true
}

# Get or create project for session, returns project ID
bws_ensure_project() {
    local session="$1"
    local project_name
    project_name=$(bws_project_name "$session")

    local project_id
    project_id=$(bws_find_project_id "$project_name")

    if [[ -z "$project_id" ]]; then
        # Create the project
        project_id=$(bws project create "$project_name" 2>/dev/null | jq -r '.id' 2>/dev/null)
        if [[ -z "$project_id" || "$project_id" == "null" ]]; then
            error "Failed to create Bitwarden project: $project_name"
        fi
    fi
    echo "$project_id"
}

# Find secret ID by key name within a project
bws_find_secret_id() {
    local project_id="$1"
    local key="$2"
    local list_output
    list_output=$(bws secret list 2>/dev/null) || return 0
    echo "$list_output" | jq -r ".[] | select(.projectId==\"$project_id\" and .key==\"$key\") | .id" 2>/dev/null || true
}

# Check if bws is configured and working
bws_is_configured() {
    # Check bws can list projects (validates token)
    bws project list -o none >/dev/null 2>&1
}

# Detect operating system and available backend
detect_backend() {
    # Allow explicit override via environment variable
    if [[ -n "${CS_SECRETS_BACKEND:-}" ]]; then
        echo "$CS_SECRETS_BACKEND"
        return
    fi

    # Bitwarden has highest priority when available and configured
    if command -v bws >/dev/null 2>&1 && command -v jq >/dev/null 2>&1; then
        if bws_is_configured; then
            echo "bitwarden"
            return
        fi
    fi

    case "$OSTYPE" in
        darwin*)
            # macOS - use Keychain
            if command -v security >/dev/null 2>&1; then
                echo "keychain"
                return
            fi
            ;;
        msys*|cygwin*|mingw*)
            # Windows (Git Bash, MSYS2, Cygwin)
            if command -v powershell.exe >/dev/null 2>&1; then
                # Check if SecretManagement module is available
                if powershell.exe -NoProfile -Command "Get-Module -ListAvailable -Name Microsoft.PowerShell.SecretManagement" 2>/dev/null | grep -q "SecretManagement"; then
                    echo "credential"
                    return
                fi
            fi
            ;;
    esac

    # Fallback to encrypted file (works everywhere with OpenSSL)
    if command -v openssl >/dev/null 2>&1; then
        echo "encrypted"
        return
    fi

    error "No supported secret storage backend found. Install OpenSSL for encrypted file support."
}

BACKEND=$(detect_backend)

# ============================================================================
# KEYCHAIN BACKEND (macOS)
# ============================================================================

keychain_service() {
    local session="$1"
    local name="$2"
    echo "cs:${session}:${name}"
}

keychain_store() {
    local session="$1"
    local name="$2"
    local value="$3"
    local service
    service=$(keychain_service "$session" "$name")

    security add-generic-password -a "$USER" -s "$service" -w "$value" -U 2>/dev/null || \
        error "Failed to store secret in Keychain"
    echo "Stored secret: $name"
}

keychain_get() {
    local session="$1"
    local name="$2"
    local service
    service=$(keychain_service "$session" "$name")

    local value
    if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
        echo "$value"
    else
        error "Secret not found: $name"
    fi
}

keychain_list() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$secrets" | while read -r name; do
            echo "  - $name"
        done
    fi
}

keychain_delete() {
    local session="$1"
    local name="$2"
    local service
    service=$(keychain_service "$session" "$name")

    if security delete-generic-password -a "$USER" -s "$service" >/dev/null 2>&1; then
        echo "Deleted secret: $name"
    else
        error "Secret not found or could not be deleted: $name"
    fi
}

keychain_purge() {
    local session="$1"
    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -z "$secrets" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    local count=0
    while read -r name; do
        [[ -z "$name" ]] && continue
        local service
        service=$(keychain_service "$session" "$name")
        if security delete-generic-password -a "$USER" -s "$service" >/dev/null 2>&1; then
            ((count++))
        fi
    done <<< "$secrets"

    echo "Purged $count secret(s) for session: $session"
}

keychain_export() {
    local session="$1"
    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -n "$secrets" ]]; then
        echo "$secrets" | while read -r name; do
            local service
            service=$(keychain_service "$session" "$name")
            local value
            if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
                local var_name
                var_name=$(echo "$name" | tr '[:lower:]-' '[:upper:]_')
                printf 'export %s=%q\n' "$var_name" "$value"
            fi
        done
    fi
}

# ============================================================================
# ENCRYPTED FILE BACKEND (Cross-platform)
# ============================================================================

get_encryption_password() {
    # Priority:
    # 1. Environment variable
    # 2. Derived from machine characteristics + salt

    if [[ -n "${CS_SECRETS_PASSWORD:-}" ]]; then
        echo "$CS_SECRETS_PASSWORD"
        return
    fi

    # Ensure secrets directory and salt exist
    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    if [[ ! -f "$SALT_FILE" ]]; then
        # Generate random salt on first use
        openssl rand -hex 32 > "$SALT_FILE"
        chmod 600 "$SALT_FILE"
    fi

    local salt
    salt=$(cat "$SALT_FILE")

    # Derive password from user + hostname + salt
    # This provides machine-specific encryption
    local machine_id="${USER}@$(hostname)"
    echo -n "${machine_id}${salt}" | openssl dgst -sha256 -r | cut -d' ' -f1
}

encrypted_file_path() {
    local session="$1"
    echo "${SECRETS_DIR}/${session}.enc"
}

encrypted_read_store() {
    local session="$1"
    local file
    file=$(encrypted_file_path "$session")

    if [[ ! -f "$file" ]]; then
        echo "{}"
        return
    fi

    local password
    password=$(get_encryption_password)

    openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 -in "$file" -pass "pass:$password" 2>/dev/null || echo "{}"
}

encrypted_write_store() {
    local session="$1"
    local data="$2"
    local file
    file=$(encrypted_file_path "$session")

    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    local password
    password=$(get_encryption_password)

    echo "$data" | openssl enc -aes-256-cbc -e -pbkdf2 -iter 100000 -out "$file" -pass "pass:$password"
    chmod 600 "$file"
}

encrypted_store() {
    local session="$1"
    local name="$2"
    local value="$3"

    local store
    store=$(encrypted_read_store "$session")

    local updated
    updated=$(echo "$store" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')

    encrypted_write_store "$session" "$updated"
    echo "Stored secret: $name"
}

encrypted_get() {
    local session="$1"
    local name="$2"

    local store
    store=$(encrypted_read_store "$session")

    local value
    value=$(echo "$store" | jq -r --arg name "$name" '.[$name] // empty')

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

encrypted_list() {
    local session="$1"

    local store
    store=$(encrypted_read_store "$session")

    local keys
    keys=$(echo "$store" | jq -r 'keys[]' 2>/dev/null || true)

    if [[ -z "$keys" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$keys" | while read -r name; do
            echo "  - $name"
        done
    fi
}

encrypted_delete() {
    local session="$1"
    local name="$2"

    local store
    store=$(encrypted_read_store "$session")

    # Check if key exists
    if ! echo "$store" | jq -e --arg name "$name" 'has($name)' >/dev/null 2>&1; then
        error "Secret not found: $name"
    fi

    local updated
    updated=$(echo "$store" | jq --arg name "$name" 'del(.[$name])')

    encrypted_write_store "$session" "$updated"
    echo "Deleted secret: $name"
}

encrypted_purge() {
    local session="$1"
    local file
    file=$(encrypted_file_path "$session")

    if [[ ! -f "$file" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    local store
    store=$(encrypted_read_store "$session")
    local count
    count=$(echo "$store" | jq 'keys | length' 2>/dev/null || echo "0")

    rm -f "$file"
    echo "Purged $count secret(s) for session: $session"
}

encrypted_export() {
    local session="$1"

    local store
    store=$(encrypted_read_store "$session")

    echo "$store" | jq -r 'to_entries[] | "export " + (.key | gsub("-"; "_") | ascii_upcase) + "=" + (.value | @sh)' 2>/dev/null || true
}

# ============================================================================
# WINDOWS CREDENTIAL MANAGER BACKEND (PowerShell)
# ============================================================================

credential_store() {
    local session="$1"
    local name="$2"
    local value="$3"
    local target="cs:${session}:${name}"

    powershell.exe -NoProfile -Command "
        \$secureValue = ConvertTo-SecureString '$value' -AsPlainText -Force
        \$cred = New-Object System.Management.Automation.PSCredential('$USER', \$secureValue)
        Set-Secret -Name '$target' -SecureStringSecret \$cred.Password -Vault 'cs-secrets' -ErrorAction SilentlyContinue
        if (-not \$?) {
            # Vault doesn't exist, create it with default store
            Register-SecretVault -Name 'cs-secrets' -ModuleName 'Microsoft.PowerShell.SecretStore' -DefaultVault
            Set-Secret -Name '$target' -SecureStringSecret \$cred.Password -Vault 'cs-secrets'
        }
    " 2>/dev/null || error "Failed to store secret"
    echo "Stored secret: $name"
}

credential_get() {
    local session="$1"
    local name="$2"
    local target="cs:${session}:${name}"

    local value
    value=$(powershell.exe -NoProfile -Command "
        \$secret = Get-Secret -Name '$target' -Vault 'cs-secrets' -AsPlainText -ErrorAction SilentlyContinue
        if (\$secret) { Write-Output \$secret }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

credential_list() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object { \$_.Name -replace '^${prefix}', '' }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$secrets" | while read -r name; do
            [[ -n "$name" ]] && echo "  - $name"
        done
    fi
}

credential_delete() {
    local session="$1"
    local name="$2"
    local target="cs:${session}:${name}"

    if powershell.exe -NoProfile -Command "Remove-Secret -Name '$target' -Vault 'cs-secrets'" 2>/dev/null; then
        echo "Deleted secret: $name"
    else
        error "Secret not found or could not be deleted: $name"
    fi
}

credential_purge() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object { \$_.Name -replace '^${prefix}', '' }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$secrets" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    local count=0
    while read -r name; do
        [[ -z "$name" ]] && continue
        local target="cs:${session}:${name}"
        if powershell.exe -NoProfile -Command "Remove-Secret -Name '$target' -Vault 'cs-secrets'" 2>/dev/null; then
            ((count++))
        fi
    done <<< "$secrets"

    echo "Purged $count secret(s) for session: $session"
}

credential_export() {
    local session="$1"
    local prefix="cs:${session}:"

    powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object {
            \$name = \$_.Name -replace '^${prefix}', ''
            \$value = Get-Secret -Name \$_.Name -Vault 'cs-secrets' -AsPlainText
            \$envName = (\$name -replace '-', '_').ToUpper()
            Write-Output \"export \$envName='\$value'\"
        }
    " 2>/dev/null | tr -d '\r'
}

# ============================================================================
# BITWARDEN SECRETS MANAGER BACKEND (bws)
# ============================================================================

bitwarden_store() {
    local session="$1"
    local name="$2"
    local value="$3"

    local project_id
    project_id=$(bws_ensure_project "$session")

    local existing_id
    existing_id=$(bws_find_secret_id "$project_id" "$name")

    if [[ -n "$existing_id" ]]; then
        # Update existing
        if ! bws secret edit "$existing_id" --value "$value" -o none >/dev/null 2>&1; then
            error "Failed to update secret in Bitwarden"
        fi
    else
        # Create new
        if ! bws secret create "$name" "$value" "$project_id" -o none >/dev/null 2>&1; then
            error "Failed to create secret in Bitwarden"
        fi
    fi
    echo "Stored secret: $name"
}

bitwarden_get() {
    local session="$1"
    local name="$2"

    local project_name
    project_name=$(bws_project_name "$session")
    local project_id
    project_id=$(bws_find_project_id "$project_name")

    if [[ -z "$project_id" ]]; then
        error "No secrets stored for session: $session"
    fi

    local value
    value=$(bws secret list 2>/dev/null | jq -r ".[] | select(.projectId==\"$project_id\" and .key==\"$name\") | .value" 2>/dev/null)

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

bitwarden_list() {
    local session="$1"

    local project_name
    project_name=$(bws_project_name "$session")
    local project_id
    project_id=$(bws_find_project_id "$project_name")

    if [[ -z "$project_id" ]]; then
        echo "No secrets stored for session: $session"
        return 0
    fi

    local secrets
    secrets=$(bws secret list 2>/dev/null | jq -r ".[] | select(.projectId==\"$project_id\") | .key" 2>/dev/null || true)

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session (Bitwarden project: $project_name)"
        echo "$secrets" | while read -r name; do
            echo "  - $name"
        done
    fi
}

bitwarden_delete() {
    local session="$1"
    local name="$2"

    local project_name
    project_name=$(bws_project_name "$session")
    local project_id
    project_id=$(bws_find_project_id "$project_name")

    if [[ -z "$project_id" ]]; then
        error "No secrets stored for session: $session"
    fi

    local secret_id
    secret_id=$(bws_find_secret_id "$project_id" "$name")

    if [[ -z "$secret_id" ]]; then
        error "Secret not found: $name"
    fi

    if bws secret delete "$secret_id" -o none >/dev/null 2>&1; then
        echo "Deleted secret: $name"
    else
        error "Failed to delete secret: $name"
    fi
}

bitwarden_purge() {
    local session="$1"

    local project_name
    project_name=$(bws_project_name "$session")
    local project_id
    project_id=$(bws_find_project_id "$project_name")

    if [[ -z "$project_id" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    # Delete the entire project (and all its secrets)
    if bws project delete "$project_id" -o none >/dev/null 2>&1; then
        echo "Purged all secrets and project for session: $session"
    else
        error "Failed to delete Bitwarden project: $project_name"
    fi
}

bitwarden_export() {
    local session="$1"

    local project_name
    project_name=$(bws_project_name "$session")
    local project_id
    project_id=$(bws_find_project_id "$project_name")

    if [[ -z "$project_id" ]]; then
        return 0  # No secrets to export
    fi

    bws secret list 2>/dev/null | jq -r ".[] | select(.projectId==\"$project_id\") | \"\(.key)=\(.value)\"" 2>/dev/null | while read -r line; do
        [[ -z "$line" ]] && continue
        local key="${line%%=*}"
        local value="${line#*=}"
        local var_name
        var_name=$(echo "$key" | tr '[:lower:]-' '[:upper:]_')
        printf 'export %s=%q\n' "$var_name" "$value"
    done
}

# ============================================================================
# BACKEND DISPATCH
# ============================================================================

backend_store() {
    case "$BACKEND" in
        bitwarden)  bitwarden_store "$@" ;;
        keychain)   keychain_store "$@" ;;
        credential) credential_store "$@" ;;
        encrypted)  encrypted_store "$@" ;;
    esac
}

backend_get() {
    case "$BACKEND" in
        bitwarden)  bitwarden_get "$@" ;;
        keychain)   keychain_get "$@" ;;
        credential) credential_get "$@" ;;
        encrypted)  encrypted_get "$@" ;;
    esac
}

backend_list() {
    case "$BACKEND" in
        bitwarden)  bitwarden_list "$@" ;;
        keychain)   keychain_list "$@" ;;
        credential) credential_list "$@" ;;
        encrypted)  encrypted_list "$@" ;;
    esac
}

backend_delete() {
    case "$BACKEND" in
        bitwarden)  bitwarden_delete "$@" ;;
        keychain)   keychain_delete "$@" ;;
        credential) credential_delete "$@" ;;
        encrypted)  encrypted_delete "$@" ;;
    esac
}

backend_purge() {
    case "$BACKEND" in
        bitwarden)  bitwarden_purge "$@" ;;
        keychain)   keychain_purge "$@" ;;
        credential) credential_purge "$@" ;;
        encrypted)  encrypted_purge "$@" ;;
    esac
}

backend_export() {
    case "$BACKEND" in
        bitwarden)  bitwarden_export "$@" ;;
        keychain)   keychain_export "$@" ;;
        credential) credential_export "$@" ;;
        encrypted)  encrypted_export "$@" ;;
    esac
}

# ============================================================================
# SYNC FILE OPERATIONS
# ============================================================================

SYNC_FILE_NAME="secrets.enc"

# Get sync file path for session (in session directory, not ~/.cs-secrets)
sync_file_path() {
    local session="$1"
    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    echo "${sessions_root}/${session}/${SYNC_FILE_NAME}"
}

# Collect all secrets as JSON from current backend
collect_secrets_json() {
    local session="$1"
    local json="{}"

    case "$BACKEND" in
        bitwarden)
            local project_name
            project_name=$(bws_project_name "$session")
            local project_id
            project_id=$(bws_find_project_id "$project_name")
            if [[ -n "$project_id" ]]; then
                json=$(bws secret list 2>/dev/null | jq "[.[] | select(.projectId==\"$project_id\")] | map({(.key): .value}) | add // {}" 2>/dev/null || echo "{}")
            fi
            ;;
        keychain)
            local secrets
            secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)
            if [[ -n "$secrets" ]]; then
                while IFS= read -r name; do
                    [[ -z "$name" ]] && continue
                    local service
                    service=$(keychain_service "$session" "$name")
                    local value
                    if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
                        json=$(echo "$json" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')
                    fi
                done <<< "$secrets"
            fi
            ;;
        credential)
            local prefix="cs:${session}:"
            local secrets
            secrets=$(powershell.exe -NoProfile -Command "
                Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object {
                    \$name = \$_.Name -replace '^${prefix}', ''
                    \$value = Get-Secret -Name \$_.Name -Vault 'cs-secrets' -AsPlainText
                    Write-Output \"\$name=\$value\"
                }
            " 2>/dev/null | tr -d '\r')
            if [[ -n "$secrets" ]]; then
                while IFS='=' read -r name value; do
                    [[ -z "$name" ]] && continue
                    json=$(echo "$json" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')
                done <<< "$secrets"
            fi
            ;;
        encrypted)
            json=$(encrypted_read_store "$session")
            ;;
    esac

    echo "$json"
}

# Export secrets to sync file (for git sync)
export_to_sync_file() {
    local session="$1"
    local output="${2:-$(sync_file_path "$session")}"

    # Require explicit password for sync (machine-derived not portable)
    if [[ -z "${CS_SECRETS_PASSWORD:-}" ]]; then
        error "CS_SECRETS_PASSWORD required for sync. Set same password on all machines."
    fi

    local secrets_json
    secrets_json=$(collect_secrets_json "$session")

    # Check if there are any secrets
    local count
    count=$(echo "$secrets_json" | jq 'keys | length')
    if [[ "$count" -eq 0 ]]; then
        echo "No secrets to export for session: $session"
        # Remove old sync file if it exists
        [[ -f "$output" ]] && rm -f "$output"
        return 0
    fi

    # Encrypt and write to sync file
    local parent_dir
    parent_dir=$(dirname "$output")
    mkdir -p "$parent_dir"

    echo "$secrets_json" | openssl enc -aes-256-cbc -e -pbkdf2 -iter 100000 \
        -out "$output" -pass "pass:$CS_SECRETS_PASSWORD"
    chmod 600 "$output"

    echo "Exported $count secret(s) to: $output"
}

# Import secrets from sync file
import_from_sync_file() {
    local session="$1"
    local input="${2:-$(sync_file_path "$session")}"
    local mode="${3:-merge}"  # merge (default) or replace

    if [[ ! -f "$input" ]]; then
        echo "No sync file found: $input"
        return 0
    fi

    # Require explicit password for sync
    if [[ -z "${CS_SECRETS_PASSWORD:-}" ]]; then
        error "CS_SECRETS_PASSWORD required for sync. Set same password on all machines."
    fi

    # Decrypt file
    local secrets_json
    if ! secrets_json=$(openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
        -in "$input" -pass "pass:$CS_SECRETS_PASSWORD" 2>/dev/null); then
        error "Failed to decrypt sync file. Check CS_SECRETS_PASSWORD."
    fi

    # Validate JSON
    if ! echo "$secrets_json" | jq empty 2>/dev/null; then
        error "Invalid sync file format."
    fi

    # Import secrets
    local imported=0
    local skipped=0

    while IFS= read -r key; do
        [[ -z "$key" ]] && continue
        local value
        value=$(echo "$secrets_json" | jq -r --arg k "$key" '.[$k]')

        # Check if secret already exists locally
        local exists=0
        backend_get "$session" "$key" >/dev/null 2>&1 && exists=1

        if [[ "$mode" == "replace" ]] || [[ $exists -eq 0 ]]; then
            backend_store "$session" "$key" "$value" >/dev/null
            ((imported++))
        else
            ((skipped++))
        fi
    done <<< "$(echo "$secrets_json" | jq -r 'keys[]')"

    if [[ $imported -gt 0 ]]; then
        echo "Imported $imported secret(s) from: $input"
    fi
    if [[ $skipped -gt 0 ]]; then
        echo "Skipped $skipped existing secret(s) (use --replace to overwrite)"
    fi
    if [[ $imported -eq 0 && $skipped -eq 0 ]]; then
        echo "No secrets in sync file."
    fi
}

# ============================================================================
# MIGRATE COMMAND
# ============================================================================

# Sensitive patterns to detect in key names (same as artifact-tracker.sh)
SENSITIVE_PATTERNS=("key" "secret" "password" "token" "credential" "auth" "apikey" "api_key")

is_sensitive_key() {
    local key="$1"
    local key_lower
    key_lower=$(echo "$key" | tr '[:upper:]' '[:lower:]')

    for pattern in "${SENSITIVE_PATTERNS[@]}"; do
        if [[ "$key_lower" == *"$pattern"* ]]; then
            return 0
        fi
    done
    return 1
}

migrate_secrets() {
    local session="$1"
    local do_redact="$2"
    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    local session_dir="$sessions_root/$session"
    local artifacts_dir="$session_dir/artifacts"

    if [[ ! -d "$artifacts_dir" ]]; then
        echo "No artifacts directory found for session: $session"
        echo "Path checked: $artifacts_dir"
        return 0
    fi

    local migrated=0
    local files_updated=0

    echo "Scanning artifacts for plaintext secrets..."
    echo ""

    # Process each file in artifacts (excluding MANIFEST.json)
    while IFS= read -r -d '' file; do
        local filename
        filename=$(basename "$file")
        [[ "$filename" == "MANIFEST.json" ]] && continue

        local content
        content=$(cat "$file")
        local new_content="$content"
        local file_had_secrets=0

        # Process each line looking for KEY=value or KEY: value patterns
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// /}" ]] && continue

            local key=""
            local value=""

            # Pattern: KEY=value or KEY="value" or KEY='value'
            if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*[\"\']?([^\"\']+)[\"\']?[[:space:]]*$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
            # Pattern: KEY: value
            elif [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*:[[:space:]]+(.+)[[:space:]]*$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
            fi

            [[ -z "$key" ]] && continue
            [[ -z "$value" ]] && continue

            # Skip if already redacted
            [[ "$value" == *"[REDACTED"* ]] && continue

            # Check if this looks like a sensitive key
            if is_sensitive_key "$key"; then
                # Store the secret
                backend_store "$session" "$key" "$value" >/dev/null
                echo "  Migrated: $key (from $filename)"
                ((migrated++))
                file_had_secrets=1

                # Prepare redacted version if requested
                if [[ "$do_redact" -eq 1 ]]; then
                    local redacted_value="[REDACTED: stored in keychain as $key]"
                    # Escape special characters for sed
                    local escaped_value
                    escaped_value=$(printf '%s\n' "$value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    local escaped_redacted
                    escaped_redacted=$(printf '%s\n' "$redacted_value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    new_content=$(echo "$new_content" | sed "s|$escaped_value|$escaped_redacted|g")
                fi
            fi
        done <<< "$content"

        # Write redacted content back if we made changes
        if [[ "$do_redact" -eq 1 && "$file_had_secrets" -eq 1 ]]; then
            echo "$new_content" > "$file"
            ((files_updated++))
        fi

    done < <(find "$artifacts_dir" -type f -print0)

    echo ""
    if [[ $migrated -eq 0 ]]; then
        echo "No plaintext secrets found to migrate."
    else
        echo "Migrated $migrated secret(s) to secure storage."
        if [[ "$do_redact" -eq 1 ]]; then
            echo "Updated $files_updated file(s) with redacted values."
        else
            echo ""
            echo "Tip: Run with --redact to replace plaintext values with redaction markers."
        fi
    fi
}

# Migrate secrets from one backend to another
migrate_backend() {
    local session="$1"
    local target_backend="$2"
    local delete_source="${3:-false}"
    local source_backend="${4:-$BACKEND}"

    # Validate target backend
    case "$target_backend" in
        bitwarden|keychain|credential|encrypted) ;;
        *) error "Invalid target backend: $target_backend. Must be one of: bitwarden, keychain, credential, encrypted" ;;
    esac

    # Validate source backend if specified
    if [[ -n "$4" ]]; then
        case "$source_backend" in
            bitwarden|keychain|credential|encrypted) ;;
            *) error "Invalid source backend: $source_backend. Must be one of: bitwarden, keychain, credential, encrypted" ;;
        esac
    fi

    if [[ "$target_backend" == "$source_backend" ]]; then
        error "Target backend '$target_backend' is the same as source backend"
    fi

    echo "Migrating secrets from '$source_backend' to '$target_backend'..."
    echo ""

    # Temporarily set BACKEND to source for collection
    local original_backend="$BACKEND"
    BACKEND="$source_backend"

    # Collect secrets from source backend as JSON
    local secrets_json
    secrets_json=$(collect_secrets_json "$session")

    # Restore original backend
    BACKEND="$original_backend"

    local count
    count=$(echo "$secrets_json" | jq 'keys | length' 2>/dev/null || echo "0")

    if [[ "$count" -eq 0 ]]; then
        echo "No secrets to migrate for session: $session"
        return 0
    fi

    echo "Found $count secret(s) to migrate"

    # Store each secret in target backend
    local migrated=0
    BACKEND="$target_backend"

    while IFS= read -r key; do
        [[ -z "$key" ]] && continue
        local value
        value=$(echo "$secrets_json" | jq -r --arg k "$key" '.[$k]')

        if backend_store "$session" "$key" "$value" >/dev/null 2>&1; then
            echo "  Migrated: $key"
            ((migrated++))
        else
            echo "  Failed: $key" >&2
        fi
    done <<< "$(echo "$secrets_json" | jq -r 'keys[]')"

    echo ""
    echo "Migrated $migrated of $count secret(s) to $target_backend"

    # Optionally delete from source
    if [[ "$delete_source" == "true" && $migrated -eq $count ]]; then
        echo ""
        echo "Purging secrets from source backend ($source_backend)..."
        BACKEND="$source_backend"
        backend_purge "$session"
    elif [[ "$delete_source" == "true" && $migrated -ne $count ]]; then
        echo ""
        echo "Skipping source purge - not all secrets migrated successfully"
    fi

    # Restore original backend
    BACKEND="$original_backend"
}

# Track which sessions have been offered migration
MIGRATION_OFFERED_FILE="${SECRETS_DIR}/.migration-offered"

# Check if migration was already offered for this session
migration_was_offered() {
    local session="$1"
    [[ -f "$MIGRATION_OFFERED_FILE" ]] && grep -qxF "$session" "$MIGRATION_OFFERED_FILE" 2>/dev/null
}

# Mark session as having been offered migration
mark_migration_offered() {
    local session="$1"
    mkdir -p "$SECRETS_DIR"
    echo "$session" >> "$MIGRATION_OFFERED_FILE"
}

# Check if keychain has secrets for this session (without using BACKEND variable)
keychain_has_secrets() {
    local session="$1"
    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | head -1 || true)
    [[ -n "$secrets" ]]
}

# Offer migration from keychain to bitwarden if applicable
maybe_offer_migration() {
    local session="$1"

    # Only offer if backend is bitwarden
    [[ "$BACKEND" != "bitwarden" ]] && return 0

    # Only on macOS where keychain exists
    [[ "$OSTYPE" != darwin* ]] && return 0

    # Skip if already offered for this session
    migration_was_offered "$session" && return 0

    # Skip if not interactive
    [[ ! -t 0 ]] && return 0

    # Check if keychain has secrets for this session
    keychain_has_secrets "$session" || return 0

    # Offer migration
    echo ""
    echo "Existing secrets found in macOS Keychain for session: $session"
    echo "Bitwarden Secrets Manager is now configured."
    printf "Would you like to migrate secrets to Bitwarden? [y/N] "
    read -r answer

    # Mark as offered regardless of answer
    mark_migration_offered "$session"

    if [[ "$answer" =~ ^[Yy]$ ]]; then
        echo ""
        migrate_backend "$session" "bitwarden" "false"
        echo ""
        printf "Delete secrets from Keychain after successful migration? [y/N] "
        read -r delete_answer
        if [[ "$delete_answer" =~ ^[Yy]$ ]]; then
            local save_backend="$BACKEND"
            BACKEND="keychain"
            backend_purge "$session"
            BACKEND="$save_backend"
        fi
        echo ""
    fi
}

# ============================================================================
# MAIN
# ============================================================================

# Parse arguments
SESSION_NAME="${CLAUDE_SESSION_NAME:-}"
COMMAND=""
SECRET_NAME=""
SECRET_VALUE=""
DO_REDACT=0
IMPORT_MODE="merge"
DELETE_SOURCE="false"
FROM_BACKEND=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        -s|--session)
            SESSION_NAME="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        set|store|get|list|ls|delete|rm|purge|export|export-file|import-file|migrate|migrate-backend|backend)
            COMMAND="$1"
            shift
            ;;
        --redact)
            DO_REDACT=1
            shift
            ;;
        --replace)
            IMPORT_MODE="replace"
            shift
            ;;
        --delete-source)
            DELETE_SOURCE="true"
            shift
            ;;
        --from)
            FROM_BACKEND="$2"
            shift 2
            ;;
        *)
            if [[ -z "$SECRET_NAME" ]]; then
                SECRET_NAME="$1"
            elif [[ -z "$SECRET_VALUE" ]]; then
                SECRET_VALUE="$1"
            fi
            shift
            ;;
    esac
done

# Handle backend command specially
if [[ "$COMMAND" == "backend" ]]; then
    echo "Storage backend: $BACKEND"
    case "$BACKEND" in
        bitwarden)  echo "Using Bitwarden Secrets Manager (bws CLI)" ;;
        keychain)   echo "Using macOS Keychain" ;;
        credential) echo "Using Windows Credential Manager (PowerShell SecretManagement)" ;;
        encrypted)  echo "Using OpenSSL-encrypted file (~/.cs-secrets/)" ;;
    esac
    exit 0
fi

# Validate session
if [[ -z "$SESSION_NAME" && -n "$COMMAND" ]]; then
    error "No session specified. Set CLAUDE_SESSION_NAME or use --session"
fi

# Offer migration if bitwarden is available and keychain has secrets
# Skip for meta-commands that don't need migration prompt
if [[ -n "$SESSION_NAME" && "$COMMAND" != "migrate-backend" && "$COMMAND" != "migrate" ]]; then
    maybe_offer_migration "$SESSION_NAME"
fi

# Execute command
case "$COMMAND" in
    store|set)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        if [[ -z "$SECRET_VALUE" ]]; then
            printf "Enter value for %s: " "$SECRET_NAME"
            read -r SECRET_VALUE
        fi
        [[ -z "$SECRET_VALUE" ]] && error "Secret value cannot be empty"
        backend_store "$SESSION_NAME" "$SECRET_NAME" "$SECRET_VALUE"
        ;;
    get)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        backend_get "$SESSION_NAME" "$SECRET_NAME"
        ;;
    list|ls)
        backend_list "$SESSION_NAME"
        ;;
    delete|rm)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        backend_delete "$SESSION_NAME" "$SECRET_NAME"
        ;;
    purge)
        backend_purge "$SESSION_NAME"
        ;;
    export)
        backend_export "$SESSION_NAME"
        ;;
    export-file)
        # SECRET_NAME holds optional file path argument
        export_to_sync_file "$SESSION_NAME" "$SECRET_NAME"
        ;;
    import-file)
        # SECRET_NAME holds optional file path argument
        import_from_sync_file "$SESSION_NAME" "$SECRET_NAME" "$IMPORT_MODE"
        ;;
    migrate)
        migrate_secrets "$SESSION_NAME" "$DO_REDACT"
        ;;
    migrate-backend)
        [[ -z "$SECRET_NAME" ]] && error "Target backend required. Usage: migrate-backend <backend> [--from <backend>] [--delete-source]"
        migrate_backend "$SESSION_NAME" "$SECRET_NAME" "$DELETE_SOURCE" "$FROM_BACKEND"
        ;;
    "")
        usage
        ;;
    *)
        error "Unknown command: $COMMAND"
        ;;
esac
