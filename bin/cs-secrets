#!/usr/bin/env bash
# ABOUTME: Cross-platform secure secrets management for cs sessions
# ABOUTME: Supports macOS Keychain, Windows Credential Manager, and encrypted file fallback

set -euo pipefail

SCRIPT_NAME=$(basename "$0")

# Configuration
SECRETS_DIR="${HOME}/.cs-secrets"
SALT_FILE="${SECRETS_DIR}/.salt"

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
    set, store <name> [val] Store a secret (prompts if value not provided)
    get <name>              Retrieve a secret value
    list, ls                List all secrets for current session
    delete, rm <name>       Delete a secret
    purge                   Delete ALL secrets for current session
    export                  Export secrets as environment variables (eval-able)
    export-file [FILE]      Export secrets to encrypted file for sync
    import-file [FILE]      Import secrets from encrypted file
    migrate [--redact]      Migrate plaintext secrets from artifact files
    migrate-backend <to>    Migrate secrets to different backend [--from <backend>] [--delete-source]
    backend                 Show which storage backend is being used

Age Commands (public-key encryption for sync):
    age init                Initialize age keypair (auto-downloads age if needed)
    age pubkey              Print your public key for sharing
    age add <file|key>      Add a recipient public key to current session
    age list                List recipients who can decrypt session secrets
    age remove <name>       Remove a recipient from session

Options:
    -s, --session <name>    Specify session (default: \$CLAUDE_SESSION_NAME)
    -h, --help              Show this help message

Backends (auto-detected, in priority order):
    keychain    macOS Keychain (most secure on macOS)
    credential  Windows Credential Manager via PowerShell
    encrypted   OpenSSL-encrypted file (cross-platform fallback)

Sync formats (for export-file/import-file):
    age         Public-key encryption (preferred, no shared password)
    enc         AES-256-CBC with shared password (legacy, requires CS_SECRETS_PASSWORD)

Environment:
    CS_SECRETS_BACKEND      Override backend (keychain, credential, encrypted)
    CS_SECRETS_PASSWORD     Master password for encrypted backend (legacy sync)
    CLAUDE_SESSION_NAME     Current session name

Examples:
    $SCRIPT_NAME store api_key              # Prompts for value
    $SCRIPT_NAME store api_key "sk-abc123"  # Store directly
    $SCRIPT_NAME get api_key                # Retrieve value
    $SCRIPT_NAME list                       # List all secrets
    eval "\$($SCRIPT_NAME export)"          # Load secrets as env vars
    $SCRIPT_NAME age init                   # Set up age encryption
    $SCRIPT_NAME age pubkey                 # Get your public key
EOF
    exit 0
}

error() {
    echo "Error: $1" >&2
    exit 1
}

# Detect operating system and available backend
detect_backend() {
    # Allow explicit override via environment variable
    if [[ -n "${CS_SECRETS_BACKEND:-}" ]]; then
        echo "$CS_SECRETS_BACKEND"
        return
    fi

    case "$OSTYPE" in
        darwin*)
            # macOS - use Keychain
            if command -v security >/dev/null 2>&1; then
                echo "keychain"
                return
            fi
            ;;
        msys*|cygwin*|mingw*)
            # Windows (Git Bash, MSYS2, Cygwin)
            if command -v powershell.exe >/dev/null 2>&1; then
                # Check if SecretManagement module is available
                if powershell.exe -NoProfile -Command "Get-Module -ListAvailable -Name Microsoft.PowerShell.SecretManagement" 2>/dev/null | grep -q "SecretManagement"; then
                    echo "credential"
                    return
                fi
            fi
            ;;
    esac

    # Fallback to encrypted file (works everywhere with OpenSSL)
    if command -v openssl >/dev/null 2>&1; then
        echo "encrypted"
        return
    fi

    error "No supported secret storage backend found. Install OpenSSL for encrypted file support."
}

BACKEND=$(detect_backend)

# ============================================================================
# KEYCHAIN BACKEND (macOS)
# ============================================================================

keychain_service() {
    local session="$1"
    local name="$2"
    echo "cs:${session}:${name}"
}

keychain_store() {
    local session="$1"
    local name="$2"
    local value="$3"
    local service
    service=$(keychain_service "$session" "$name")

    security add-generic-password -a "$USER" -s "$service" -w "$value" -U 2>/dev/null || \
        error "Failed to store secret in Keychain"
    echo "Stored secret: $name"
}

keychain_get() {
    local session="$1"
    local name="$2"
    local service
    service=$(keychain_service "$session" "$name")

    local value
    if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
        echo "$value"
    else
        error "Secret not found: $name"
    fi
}

keychain_list() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$secrets" | while read -r name; do
            echo "  - $name"
        done
    fi
}

keychain_delete() {
    local session="$1"
    local name="$2"
    local service
    service=$(keychain_service "$session" "$name")

    if security delete-generic-password -a "$USER" -s "$service" >/dev/null 2>&1; then
        echo "Deleted secret: $name"
    else
        error "Secret not found or could not be deleted: $name"
    fi
}

keychain_purge() {
    local session="$1"
    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -z "$secrets" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    local count=0
    while read -r name; do
        [[ -z "$name" ]] && continue
        local service
        service=$(keychain_service "$session" "$name")
        if security delete-generic-password -a "$USER" -s "$service" >/dev/null 2>&1; then
            ((count++))
        fi
    done <<< "$secrets"

    echo "Purged $count secret(s) for session: $session"
}

keychain_export() {
    local session="$1"
    local secrets
    secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)

    if [[ -n "$secrets" ]]; then
        echo "$secrets" | while read -r name; do
            local service
            service=$(keychain_service "$session" "$name")
            local value
            if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
                local var_name
                var_name=$(echo "$name" | tr '[:lower:]-' '[:upper:]_')
                printf 'export %s=%q\n' "$var_name" "$value"
            fi
        done
    fi
}

# ============================================================================
# ENCRYPTED FILE BACKEND (Cross-platform)
# ============================================================================

get_encryption_password() {
    # Priority:
    # 1. Environment variable
    # 2. Derived from machine characteristics + salt

    if [[ -n "${CS_SECRETS_PASSWORD:-}" ]]; then
        echo "$CS_SECRETS_PASSWORD"
        return
    fi

    # Ensure secrets directory and salt exist
    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    if [[ ! -f "$SALT_FILE" ]]; then
        # Generate random salt on first use
        openssl rand -hex 32 > "$SALT_FILE"
        chmod 600 "$SALT_FILE"
    fi

    local salt
    salt=$(cat "$SALT_FILE")

    # Derive password from user + hostname + salt
    # This provides machine-specific encryption
    local machine_id="${USER}@$(hostname)"
    echo -n "${machine_id}${salt}" | openssl dgst -sha256 -r | cut -d' ' -f1
}

encrypted_file_path() {
    local session="$1"
    echo "${SECRETS_DIR}/${session}.enc"
}

encrypted_read_store() {
    local session="$1"
    local file
    file=$(encrypted_file_path "$session")

    if [[ ! -f "$file" ]]; then
        echo "{}"
        return
    fi

    local password
    password=$(get_encryption_password)

    openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 -in "$file" -pass "pass:$password" 2>/dev/null || echo "{}"
}

encrypted_write_store() {
    local session="$1"
    local data="$2"
    local file
    file=$(encrypted_file_path "$session")

    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    local password
    password=$(get_encryption_password)

    echo "$data" | openssl enc -aes-256-cbc -e -pbkdf2 -iter 100000 -out "$file" -pass "pass:$password"
    chmod 600 "$file"
}

encrypted_store() {
    local session="$1"
    local name="$2"
    local value="$3"

    local store
    store=$(encrypted_read_store "$session")

    local updated
    updated=$(echo "$store" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')

    encrypted_write_store "$session" "$updated"
    echo "Stored secret: $name"
}

encrypted_get() {
    local session="$1"
    local name="$2"

    local store
    store=$(encrypted_read_store "$session")

    local value
    value=$(echo "$store" | jq -r --arg name "$name" '.[$name] // empty')

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

encrypted_list() {
    local session="$1"

    local store
    store=$(encrypted_read_store "$session")

    local keys
    keys=$(echo "$store" | jq -r 'keys[]' 2>/dev/null || true)

    if [[ -z "$keys" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$keys" | while read -r name; do
            echo "  - $name"
        done
    fi
}

encrypted_delete() {
    local session="$1"
    local name="$2"

    local store
    store=$(encrypted_read_store "$session")

    # Check if key exists
    if ! echo "$store" | jq -e --arg name "$name" 'has($name)' >/dev/null 2>&1; then
        error "Secret not found: $name"
    fi

    local updated
    updated=$(echo "$store" | jq --arg name "$name" 'del(.[$name])')

    encrypted_write_store "$session" "$updated"
    echo "Deleted secret: $name"
}

encrypted_purge() {
    local session="$1"
    local file
    file=$(encrypted_file_path "$session")

    if [[ ! -f "$file" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    local store
    store=$(encrypted_read_store "$session")
    local count
    count=$(echo "$store" | jq 'keys | length' 2>/dev/null || echo "0")

    rm -f "$file"
    echo "Purged $count secret(s) for session: $session"
}

encrypted_export() {
    local session="$1"

    local store
    store=$(encrypted_read_store "$session")

    echo "$store" | jq -r 'to_entries[] | "export " + (.key | gsub("-"; "_") | ascii_upcase) + "=" + (.value | @sh)' 2>/dev/null || true
}

# ============================================================================
# WINDOWS CREDENTIAL MANAGER BACKEND (PowerShell)
# ============================================================================

credential_store() {
    local session="$1"
    local name="$2"
    local value="$3"
    local target="cs:${session}:${name}"

    powershell.exe -NoProfile -Command "
        \$secureValue = ConvertTo-SecureString '$value' -AsPlainText -Force
        \$cred = New-Object System.Management.Automation.PSCredential('$USER', \$secureValue)
        Set-Secret -Name '$target' -SecureStringSecret \$cred.Password -Vault 'cs-secrets' -ErrorAction SilentlyContinue
        if (-not \$?) {
            # Vault doesn't exist, create it with default store
            Register-SecretVault -Name 'cs-secrets' -ModuleName 'Microsoft.PowerShell.SecretStore' -DefaultVault
            Set-Secret -Name '$target' -SecureStringSecret \$cred.Password -Vault 'cs-secrets'
        }
    " 2>/dev/null || error "Failed to store secret"
    echo "Stored secret: $name"
}

credential_get() {
    local session="$1"
    local name="$2"
    local target="cs:${session}:${name}"

    local value
    value=$(powershell.exe -NoProfile -Command "
        \$secret = Get-Secret -Name '$target' -Vault 'cs-secrets' -AsPlainText -ErrorAction SilentlyContinue
        if (\$secret) { Write-Output \$secret }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$value" ]]; then
        error "Secret not found: $name"
    fi
    echo "$value"
}

credential_list() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object { \$_.Name -replace '^${prefix}', '' }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$secrets" ]]; then
        echo "No secrets stored for session: $session"
    else
        echo "Secrets for session: $session"
        echo "$secrets" | while read -r name; do
            [[ -n "$name" ]] && echo "  - $name"
        done
    fi
}

credential_delete() {
    local session="$1"
    local name="$2"
    local target="cs:${session}:${name}"

    if powershell.exe -NoProfile -Command "Remove-Secret -Name '$target' -Vault 'cs-secrets'" 2>/dev/null; then
        echo "Deleted secret: $name"
    else
        error "Secret not found or could not be deleted: $name"
    fi
}

credential_purge() {
    local session="$1"
    local prefix="cs:${session}:"

    local secrets
    secrets=$(powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object { \$_.Name -replace '^${prefix}', '' }
    " 2>/dev/null | tr -d '\r')

    if [[ -z "$secrets" ]]; then
        echo "No secrets to purge for session: $session"
        return 0
    fi

    local count=0
    while read -r name; do
        [[ -z "$name" ]] && continue
        local target="cs:${session}:${name}"
        if powershell.exe -NoProfile -Command "Remove-Secret -Name '$target' -Vault 'cs-secrets'" 2>/dev/null; then
            ((count++))
        fi
    done <<< "$secrets"

    echo "Purged $count secret(s) for session: $session"
}

credential_export() {
    local session="$1"
    local prefix="cs:${session}:"

    powershell.exe -NoProfile -Command "
        Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object {
            \$name = \$_.Name -replace '^${prefix}', ''
            \$value = Get-Secret -Name \$_.Name -Vault 'cs-secrets' -AsPlainText
            \$envName = (\$name -replace '-', '_').ToUpper()
            Write-Output \"export \$envName='\$value'\"
        }
    " 2>/dev/null | tr -d '\r'
}

# ============================================================================
# AGE ENCRYPTION (Public-key based sync)
# ============================================================================

AGE_KEY_DIR="${SECRETS_DIR}"
AGE_KEY_FILE="${AGE_KEY_DIR}/age.key"
AGE_PUB_FILE="${AGE_KEY_DIR}/age.pub"
AGE_BIN=""  # Set by age_find_binary

# Find age binary (checks PATH and our install location)
age_find_binary() {
    # Check if already found
    if [[ -n "$AGE_BIN" && -x "$AGE_BIN" ]]; then
        echo "$AGE_BIN"
        return 0
    fi

    # Check PATH first
    if command -v age &>/dev/null; then
        AGE_BIN=$(command -v age)
        echo "$AGE_BIN"
        return 0
    fi

    # Check our install location
    if [[ -x "$HOME/.local/bin/age" ]]; then
        AGE_BIN="$HOME/.local/bin/age"
        echo "$AGE_BIN"
        return 0
    fi

    return 1
}

# Check if age is available (without downloading)
age_available() {
    age_find_binary &>/dev/null
}

# Download age binary if not found
age_ensure_binary() {
    # Already available?
    if age_find_binary &>/dev/null; then
        return 0
    fi

    echo "age not found. Downloading for secure secret sync..." >&2

    # Detect platform
    local os arch url
    case "$(uname -s)" in
        Darwin) os="darwin" ;;
        Linux)  os="linux" ;;
        MINGW*|MSYS*|CYGWIN*) os="windows" ;;
        *)
            echo "Warning: Unsupported OS for age auto-download" >&2
            return 1
            ;;
    esac

    case "$(uname -m)" in
        x86_64|amd64) arch="amd64" ;;
        arm64|aarch64) arch="arm64" ;;
        armv7l) arch="arm" ;;
        *)
            echo "Warning: Unsupported architecture for age auto-download" >&2
            return 1
            ;;
    esac

    url="https://dl.filippo.io/age/latest?for=${os}/${arch}"

    # Create temp directory for download
    local tmpdir
    tmpdir=$(mktemp -d)

    # Download and extract
    if curl -fsSL "$url" 2>/dev/null | tar xz -C "$tmpdir" 2>/dev/null; then
        mkdir -p "$HOME/.local/bin"

        # Handle both tarball structures (age/ prefix or flat)
        if [[ -f "$tmpdir/age/age" ]]; then
            mv "$tmpdir/age/age" "$HOME/.local/bin/"
            mv "$tmpdir/age/age-keygen" "$HOME/.local/bin/"
        elif [[ -f "$tmpdir/age" ]]; then
            mv "$tmpdir/age" "$HOME/.local/bin/"
            mv "$tmpdir/age-keygen" "$HOME/.local/bin/"
        else
            rm -rf "$tmpdir"
            echo "Warning: Unexpected archive structure" >&2
            return 1
        fi

        chmod +x "$HOME/.local/bin/age" "$HOME/.local/bin/age-keygen"
        rm -rf "$tmpdir"

        AGE_BIN="$HOME/.local/bin/age"
        echo "Installed age to ~/.local/bin/" >&2
        return 0
    else
        rm -rf "$tmpdir"
        echo "Warning: Failed to download age. Falling back to encrypted file sync." >&2
        return 1
    fi
}

# Generate keypair if not exists
age_ensure_keypair() {
    # Need age binary first
    if ! age_ensure_binary; then
        return 1
    fi

    mkdir -p "$AGE_KEY_DIR"
    chmod 700 "$AGE_KEY_DIR"

    if [[ -f "$AGE_KEY_FILE" ]]; then
        # Key exists, ensure pubkey is extracted
        if [[ ! -f "$AGE_PUB_FILE" ]]; then
            grep "^# public key:" "$AGE_KEY_FILE" | sed 's/^# public key: //' > "$AGE_PUB_FILE"
        fi
        return 0
    fi

    echo "Generating age keypair..." >&2

    # Generate new keypair
    local keygen_bin
    keygen_bin="${AGE_BIN%age}age-keygen"
    if [[ ! -x "$keygen_bin" ]]; then
        keygen_bin="$HOME/.local/bin/age-keygen"
    fi

    "$keygen_bin" -o "$AGE_KEY_FILE" 2>/dev/null
    chmod 600 "$AGE_KEY_FILE"

    # Extract public key
    grep "^# public key:" "$AGE_KEY_FILE" | sed 's/^# public key: //' > "$AGE_PUB_FILE"

    echo "Created keypair at $AGE_KEY_FILE" >&2
    echo "Public key: $(cat "$AGE_PUB_FILE")" >&2
    return 0
}

# Get this machine's public key
age_get_pubkey() {
    if [[ ! -f "$AGE_PUB_FILE" ]]; then
        if ! age_ensure_keypair; then
            return 1
        fi
    fi
    cat "$AGE_PUB_FILE"
}

# Get machine identifier for public key naming
age_get_machine_id() {
    echo "${USER}@$(hostname -s 2>/dev/null || hostname)"
}

# Get recipients directory for a session
age_recipients_dir() {
    local session="$1"
    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    echo "${sessions_root}/${session}/.cs/age-recipients"
}

# Encrypt secrets JSON to age format
age_encrypt_secrets() {
    local session="$1"
    local secrets_json="$2"
    local output="$3"

    local age_bin
    if ! age_bin=$(age_find_binary); then
        return 1
    fi

    local recipients_dir
    recipients_dir=$(age_recipients_dir "$session")

    if [[ ! -d "$recipients_dir" ]] || [[ -z "$(ls -A "$recipients_dir" 2>/dev/null)" ]]; then
        echo "No age recipients configured. Run: cs -secrets age add <pubkey-file>" >&2
        return 1
    fi

    # Build recipient arguments
    local recipient_args=()
    for pubfile in "$recipients_dir"/*.pub; do
        [[ -f "$pubfile" ]] || continue
        recipient_args+=(-r "$(cat "$pubfile")")
    done

    if [[ ${#recipient_args[@]} -eq 0 ]]; then
        echo "No valid recipients found" >&2
        return 1
    fi

    # Encrypt
    echo "$secrets_json" | "$age_bin" "${recipient_args[@]}" -o "$output"
}

# Decrypt secrets from age format
age_decrypt_secrets() {
    local input="$1"

    local age_bin
    if ! age_bin=$(age_find_binary); then
        return 1
    fi

    if [[ ! -f "$AGE_KEY_FILE" ]]; then
        echo "No age identity found at $AGE_KEY_FILE" >&2
        return 1
    fi

    "$age_bin" -d -i "$AGE_KEY_FILE" < "$input"
}

# ============================================================================
# BACKEND DISPATCH
# ============================================================================

backend_store() {
    case "$BACKEND" in
        keychain)   keychain_store "$@" ;;
        credential) credential_store "$@" ;;
        encrypted)  encrypted_store "$@" ;;
    esac
}

backend_get() {
    case "$BACKEND" in
        keychain)   keychain_get "$@" ;;
        credential) credential_get "$@" ;;
        encrypted)  encrypted_get "$@" ;;
    esac
}

backend_list() {
    case "$BACKEND" in
        keychain)   keychain_list "$@" ;;
        credential) credential_list "$@" ;;
        encrypted)  encrypted_list "$@" ;;
    esac
}

backend_delete() {
    case "$BACKEND" in
        keychain)   keychain_delete "$@" ;;
        credential) credential_delete "$@" ;;
        encrypted)  encrypted_delete "$@" ;;
    esac
}

backend_purge() {
    case "$BACKEND" in
        keychain)   keychain_purge "$@" ;;
        credential) credential_purge "$@" ;;
        encrypted)  encrypted_purge "$@" ;;
    esac
}

backend_export() {
    case "$BACKEND" in
        keychain)   keychain_export "$@" ;;
        credential) credential_export "$@" ;;
        encrypted)  encrypted_export "$@" ;;
    esac
}

# ============================================================================
# SYNC FILE OPERATIONS
# ============================================================================

# Get sync file paths for session (in session directory, not ~/.cs-secrets)
# Returns path for specified format, or detects existing file
sync_file_path() {
    local session="$1"
    local format="${2:-}"  # "age", "enc", or empty for auto-detect
    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    local meta_dir="${sessions_root}/${session}/.cs"

    case "$format" in
        age) echo "${meta_dir}/secrets.age" ;;
        enc) echo "${meta_dir}/secrets.enc" ;;
        *)
            # Auto-detect: prefer age if exists, then enc
            if [[ -f "${meta_dir}/secrets.age" ]]; then
                echo "${meta_dir}/secrets.age"
            elif [[ -f "${meta_dir}/secrets.enc" ]]; then
                echo "${meta_dir}/secrets.enc"
            else
                # Default to age if recipients exist, else enc
                local recipients_dir
                recipients_dir=$(age_recipients_dir "$session")
                if [[ -d "$recipients_dir" ]] && [[ -n "$(ls -A "$recipients_dir" 2>/dev/null)" ]]; then
                    echo "${meta_dir}/secrets.age"
                else
                    echo "${meta_dir}/secrets.enc"
                fi
            fi
            ;;
    esac
}

# Detect sync file format from file path
sync_file_format() {
    local file="$1"
    case "$file" in
        *.age) echo "age" ;;
        *.enc) echo "enc" ;;
        *) echo "unknown" ;;
    esac
}

# Collect all secrets as JSON from current backend
collect_secrets_json() {
    local session="$1"
    local json="{}"

    case "$BACKEND" in
        keychain)
            local secrets
            secrets=$(security dump-keychain 2>/dev/null | grep -o "\"svce\"<blob>=\"cs:${session}:[^\"]*\"" | sed "s/\"svce\"<blob>=\"cs:${session}://;s/\"$//" || true)
            if [[ -n "$secrets" ]]; then
                while IFS= read -r name; do
                    [[ -z "$name" ]] && continue
                    local service
                    service=$(keychain_service "$session" "$name")
                    local value
                    if value=$(security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null); then
                        json=$(echo "$json" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')
                    fi
                done <<< "$secrets"
            fi
            ;;
        credential)
            local prefix="cs:${session}:"
            local secrets
            secrets=$(powershell.exe -NoProfile -Command "
                Get-SecretInfo -Vault 'cs-secrets' | Where-Object { \$_.Name -like '${prefix}*' } | ForEach-Object {
                    \$name = \$_.Name -replace '^${prefix}', ''
                    \$value = Get-Secret -Name \$_.Name -Vault 'cs-secrets' -AsPlainText
                    Write-Output \"\$name=\$value\"
                }
            " 2>/dev/null | tr -d '\r')
            if [[ -n "$secrets" ]]; then
                while IFS='=' read -r name value; do
                    [[ -z "$name" ]] && continue
                    json=$(echo "$json" | jq --arg name "$name" --arg value "$value" '.[$name] = $value')
                done <<< "$secrets"
            fi
            ;;
        encrypted)
            json=$(encrypted_read_store "$session")
            ;;
    esac

    echo "$json"
}

# Export secrets to sync file (for git sync)
# Prefers age encryption if available and recipients configured, else falls back to password-encrypted .enc
export_to_sync_file() {
    local session="$1"
    local output="${2:-}"

    local secrets_json
    secrets_json=$(collect_secrets_json "$session")

    # Check if there are any secrets
    local count
    count=$(echo "$secrets_json" | jq 'keys | length')
    if [[ "$count" -eq 0 ]]; then
        echo "No secrets to export for session: $session"
        return 0
    fi

    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    local meta_dir="${sessions_root}/${session}/.cs"
    mkdir -p "$meta_dir"

    # Determine encryption method
    local use_age=false
    local recipients_dir
    recipients_dir=$(age_recipients_dir "$session")

    # Auto-setup age if available but not yet configured for this session
    if age_available; then
        if [[ ! -d "$recipients_dir" ]] || [[ -z "$(ls -A "$recipients_dir" 2>/dev/null)" ]]; then
            # No recipients yet - auto-add self if keypair exists or can be created
            if age_ensure_keypair 2>/dev/null; then
                mkdir -p "$recipients_dir"
                local machine_id
                machine_id=$(age_get_machine_id)
                local pubkey
                pubkey=$(age_get_pubkey)
                echo "$pubkey" > "$recipients_dir/${machine_id}.pub"
                echo "Auto-configured age encryption for session (added $(age_get_machine_id))"
            fi
        fi
    fi

    if age_available && [[ -d "$recipients_dir" ]] && [[ -n "$(ls -A "$recipients_dir" 2>/dev/null)" ]]; then
        use_age=true
    fi

    if [[ "$use_age" == "true" ]]; then
        # Use age encryption
        local age_output="${output:-${meta_dir}/secrets.age}"

        if age_encrypt_secrets "$session" "$secrets_json" "$age_output"; then
            chmod 600 "$age_output"
            echo "Exported $count secret(s) to: $age_output (age encrypted)"

            # Clean up old .enc file if we successfully wrote .age
            local old_enc="${meta_dir}/secrets.enc"
            if [[ -f "$old_enc" ]]; then
                rm -f "$old_enc"
                echo "Removed legacy secrets.enc (migrated to age)"
            fi
        else
            echo "Age encryption failed, falling back to password encryption" >&2
            use_age=false
        fi
    fi

    if [[ "$use_age" == "false" ]]; then
        # Fall back to password-encrypted .enc
        if [[ -z "${CS_SECRETS_PASSWORD:-}" ]]; then
            error "No age recipients configured and CS_SECRETS_PASSWORD not set.
Either:
  1. Set up age encryption: cs -secrets age init && cs -secrets age add ~/.cs-secrets/age.pub
  2. Or set CS_SECRETS_PASSWORD for legacy password-based sync"
        fi

        local enc_output="${output:-${meta_dir}/secrets.enc}"

        echo "$secrets_json" | openssl enc -aes-256-cbc -e -pbkdf2 -iter 100000 \
            -out "$enc_output" -pass "pass:$CS_SECRETS_PASSWORD"
        chmod 600 "$enc_output"

        echo "Exported $count secret(s) to: $enc_output (password encrypted)"
    fi
}

# Import secrets from sync file
# Auto-detects format: .age (public-key) or .enc (password-based)
import_from_sync_file() {
    local session="$1"
    local input="${2:-}"
    local mode="${3:-merge}"  # merge (default) or replace

    # If no input specified, auto-detect existing file
    if [[ -z "$input" ]]; then
        input=$(sync_file_path "$session")
    fi

    if [[ ! -f "$input" ]]; then
        echo "No sync file found: $input"
        return 0
    fi

    local format
    format=$(sync_file_format "$input")

    local secrets_json=""

    case "$format" in
        age)
            # Decrypt with age
            if ! age_available; then
                error "age binary not found. Run: cs -secrets age init"
            fi
            if ! secrets_json=$(age_decrypt_secrets "$input"); then
                error "Failed to decrypt age file. Your key may not be in the recipients list."
            fi
            ;;
        enc)
            # Decrypt with password
            if [[ -z "${CS_SECRETS_PASSWORD:-}" ]]; then
                error "CS_SECRETS_PASSWORD required to decrypt .enc file. Set same password used during export."
            fi
            if ! secrets_json=$(openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
                -in "$input" -pass "pass:$CS_SECRETS_PASSWORD" 2>/dev/null); then
                error "Failed to decrypt sync file. Check CS_SECRETS_PASSWORD."
            fi
            ;;
        *)
            error "Unknown sync file format: $input"
            ;;
    esac

    # Validate JSON
    if ! echo "$secrets_json" | jq empty 2>/dev/null; then
        error "Invalid sync file format."
    fi

    # Import secrets
    local imported=0
    local skipped=0

    while IFS= read -r key; do
        [[ -z "$key" ]] && continue
        local value
        value=$(echo "$secrets_json" | jq -r --arg k "$key" '.[$k]')

        # Check if secret already exists locally (subshell prevents error() from killing parent)
        local exists=0
        (backend_get "$session" "$key" >/dev/null 2>&1) && exists=1

        if [[ "$mode" == "replace" ]] || [[ $exists -eq 0 ]]; then
            backend_store "$session" "$key" "$value" >/dev/null
            ((imported++))
        else
            ((skipped++))
        fi
    done <<< "$(echo "$secrets_json" | jq -r 'keys[]')"

    if [[ $imported -gt 0 ]]; then
        echo "Imported $imported secret(s) from: $input ($format format)"
    fi
    if [[ $skipped -gt 0 ]]; then
        echo "Skipped $skipped existing secret(s) (use --replace to overwrite)"
    fi
    if [[ $imported -eq 0 && $skipped -eq 0 ]]; then
        echo "No secrets in sync file."
    fi
}

# ============================================================================
# MIGRATE COMMAND
# ============================================================================

# Sensitive patterns to detect in key names (same as artifact-tracker.sh)
SENSITIVE_PATTERNS=("key" "secret" "password" "token" "credential" "auth" "apikey" "api_key")

is_sensitive_key() {
    local key="$1"
    local key_lower
    key_lower=$(echo "$key" | tr '[:upper:]' '[:lower:]')

    for pattern in "${SENSITIVE_PATTERNS[@]}"; do
        if [[ "$key_lower" == *"$pattern"* ]]; then
            return 0
        fi
    done
    return 1
}

migrate_secrets() {
    local session="$1"
    local do_redact="$2"
    local sessions_root="${CS_SESSIONS_ROOT:-$HOME/.claude-sessions}"
    local session_dir="$sessions_root/$session"
    local artifacts_dir="$session_dir/.cs/artifacts"

    if [[ ! -d "$artifacts_dir" ]]; then
        echo "No artifacts directory found for session: $session"
        echo "Path checked: $artifacts_dir"
        return 0
    fi

    local migrated=0
    local files_updated=0

    echo "Scanning artifacts for plaintext secrets..."
    echo ""

    # Process each file in artifacts (excluding MANIFEST.json)
    while IFS= read -r -d '' file; do
        local filename
        filename=$(basename "$file")
        [[ "$filename" == "MANIFEST.json" ]] && continue

        local content
        content=$(cat "$file")
        local new_content="$content"
        local file_had_secrets=0

        # Process each line looking for KEY=value or KEY: value patterns
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// /}" ]] && continue

            local key=""
            local value=""

            # Pattern: KEY=value or KEY="value" or KEY='value'
            if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*[\"\']?([^\"\']+)[\"\']?[[:space:]]*$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
            # Pattern: KEY: value
            elif [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*:[[:space:]]+(.+)[[:space:]]*$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
            fi

            [[ -z "$key" ]] && continue
            [[ -z "$value" ]] && continue

            # Skip if already redacted
            [[ "$value" == *"[REDACTED"* ]] && continue

            # Check if this looks like a sensitive key
            if is_sensitive_key "$key"; then
                # Store the secret
                backend_store "$session" "$key" "$value" >/dev/null
                echo "  Migrated: $key (from $filename)"
                ((migrated++))
                file_had_secrets=1

                # Prepare redacted version if requested
                if [[ "$do_redact" -eq 1 ]]; then
                    local redacted_value="[REDACTED: stored in keychain as $key]"
                    # Escape special characters for sed
                    local escaped_value
                    escaped_value=$(printf '%s\n' "$value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    local escaped_redacted
                    escaped_redacted=$(printf '%s\n' "$redacted_value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    new_content=$(echo "$new_content" | sed "s|$escaped_value|$escaped_redacted|g")
                fi
            fi
        done <<< "$content"

        # Write redacted content back if we made changes
        if [[ "$do_redact" -eq 1 && "$file_had_secrets" -eq 1 ]]; then
            echo "$new_content" > "$file"
            ((files_updated++))
        fi

    done < <(find "$artifacts_dir" -type f -print0)

    echo ""
    if [[ $migrated -eq 0 ]]; then
        echo "No plaintext secrets found to migrate."
    else
        echo "Migrated $migrated secret(s) to secure storage."
        if [[ "$do_redact" -eq 1 ]]; then
            echo "Updated $files_updated file(s) with redacted values."
        else
            echo ""
            echo "Tip: Run with --redact to replace plaintext values with redaction markers."
        fi
    fi
}

# Migrate secrets from one backend to another
migrate_backend() {
    local session="$1"
    local target_backend="$2"
    local delete_source="${3:-false}"
    local source_backend="${4:-$BACKEND}"

    # Validate target backend
    case "$target_backend" in
        keychain|credential|encrypted) ;;
        *) error "Invalid target backend: $target_backend. Must be one of: keychain, credential, encrypted" ;;
    esac

    # Validate source backend if specified
    if [[ -n "$4" ]]; then
        case "$source_backend" in
            keychain|credential|encrypted) ;;
            *) error "Invalid source backend: $source_backend. Must be one of: keychain, credential, encrypted" ;;
        esac
    fi

    if [[ "$target_backend" == "$source_backend" ]]; then
        error "Target backend '$target_backend' is the same as source backend"
    fi

    echo "Migrating secrets from '$source_backend' to '$target_backend'..."
    echo ""

    # Temporarily set BACKEND to source for collection
    local original_backend="$BACKEND"
    BACKEND="$source_backend"

    # Collect secrets from source backend as JSON
    local secrets_json
    secrets_json=$(collect_secrets_json "$session")

    # Restore original backend
    BACKEND="$original_backend"

    local count
    count=$(echo "$secrets_json" | jq 'keys | length' 2>/dev/null || echo "0")

    if [[ "$count" -eq 0 ]]; then
        echo "No secrets to migrate for session: $session"
        return 0
    fi

    echo "Found $count secret(s) to migrate"

    # Store each secret in target backend
    local migrated=0
    BACKEND="$target_backend"

    while IFS= read -r key; do
        [[ -z "$key" ]] && continue
        local value
        value=$(echo "$secrets_json" | jq -r --arg k "$key" '.[$k]')

        if backend_store "$session" "$key" "$value" >/dev/null 2>&1; then
            echo "  Migrated: $key"
            ((migrated++))
        else
            echo "  Failed: $key" >&2
        fi
    done <<< "$(echo "$secrets_json" | jq -r 'keys[]')"

    echo ""
    echo "Migrated $migrated of $count secret(s) to $target_backend"

    # Optionally delete from source
    if [[ "$delete_source" == "true" && $migrated -eq $count ]]; then
        echo ""
        echo "Purging secrets from source backend ($source_backend)..."
        BACKEND="$source_backend"
        backend_purge "$session"
    elif [[ "$delete_source" == "true" && $migrated -ne $count ]]; then
        echo ""
        echo "Skipping source purge - not all secrets migrated successfully"
    fi

    # Restore original backend
    BACKEND="$original_backend"
}

# ============================================================================
# MAIN
# ============================================================================

# Parse arguments
SESSION_NAME="${CLAUDE_SESSION_NAME:-}"
COMMAND=""
AGE_SUBCOMMAND=""
SECRET_NAME=""
SECRET_VALUE=""
DO_REDACT=0
IMPORT_MODE="merge"
DELETE_SOURCE="false"
FROM_BACKEND=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        -s|--session)
            SESSION_NAME="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        age)
            COMMAND="age"
            AGE_SUBCOMMAND="${2:-}"
            # Capture argument after subcommand (e.g., pubkey file or recipient name)
            SECRET_NAME="${3:-}"
            shift
            [[ -n "$AGE_SUBCOMMAND" ]] && shift
            [[ -n "$SECRET_NAME" ]] && shift
            ;;
        set|store|get|list|ls|delete|rm|purge|export|export-file|import-file|migrate|migrate-backend|backend)
            COMMAND="$1"
            shift
            ;;
        --redact)
            DO_REDACT=1
            shift
            ;;
        --replace)
            IMPORT_MODE="replace"
            shift
            ;;
        --delete-source)
            DELETE_SOURCE="true"
            shift
            ;;
        --from)
            FROM_BACKEND="$2"
            shift 2
            ;;
        *)
            if [[ -z "$SECRET_NAME" ]]; then
                SECRET_NAME="$1"
            elif [[ -z "$SECRET_VALUE" ]]; then
                SECRET_VALUE="$1"
            fi
            shift
            ;;
    esac
done

# Handle backend command specially
if [[ "$COMMAND" == "backend" ]]; then
    echo "Storage backend: $BACKEND"
    case "$BACKEND" in
        keychain)   echo "Using macOS Keychain" ;;
        credential) echo "Using Windows Credential Manager (PowerShell SecretManagement)" ;;
        encrypted)  echo "Using OpenSSL-encrypted file (~/.cs-secrets/)" ;;
    esac
    exit 0
fi

# Handle age commands (some don't require session)
if [[ "$COMMAND" == "age" ]]; then
    case "$AGE_SUBCOMMAND" in
        init)
            # Initialize age - no session needed
            if age_ensure_keypair; then
                echo "Age encryption ready."
                echo "Public key: $(age_get_pubkey)"
            else
                exit 1
            fi
            exit 0
            ;;
        pubkey)
            # Get public key - no session needed
            if pubkey=$(age_get_pubkey); then
                echo "$pubkey"
            else
                exit 1
            fi
            exit 0
            ;;
        add)
            # Add recipient - requires session
            [[ -z "$SESSION_NAME" ]] && error "No session specified. Set CLAUDE_SESSION_NAME or use --session"
            [[ -z "$SECRET_NAME" ]] && error "Usage: age add <pubkey-file-or-key>"

            _age_recipients_dir=$(age_recipients_dir "$SESSION_NAME")
            mkdir -p "$_age_recipients_dir"

            if [[ -f "$SECRET_NAME" ]]; then
                # It's a file
                _age_pubkey=$(cat "$SECRET_NAME")
                _age_machine_id=$(basename "$SECRET_NAME" .pub)
            elif [[ "$SECRET_NAME" == age1* ]]; then
                # It's a raw public key
                _age_pubkey="$SECRET_NAME"
                _age_machine_id="recipient-$(date +%s)"
            else
                error "Invalid public key. Must be a file or age1... public key"
            fi

            # Validate it looks like an age public key
            if [[ ! "$_age_pubkey" == age1* ]]; then
                error "Invalid age public key format"
            fi

            echo "$_age_pubkey" > "$_age_recipients_dir/${_age_machine_id}.pub"
            echo "Added recipient: $_age_machine_id"
            echo "Public key: $_age_pubkey"
            exit 0
            ;;
        list|ls)
            # List recipients - requires session
            [[ -z "$SESSION_NAME" ]] && error "No session specified. Set CLAUDE_SESSION_NAME or use --session"

            _age_recipients_dir=$(age_recipients_dir "$SESSION_NAME")

            if [[ ! -d "$_age_recipients_dir" ]] || [[ -z "$(ls -A "$_age_recipients_dir" 2>/dev/null)" ]]; then
                echo "No recipients configured for session: $SESSION_NAME"
                echo ""
                echo "Add recipients with: cs -secrets age add <pubkey-file>"
                exit 0
            fi

            echo "Recipients for session: $SESSION_NAME"
            for _age_pubfile in "$_age_recipients_dir"/*.pub; do
                [[ -f "$_age_pubfile" ]] || continue
                _age_name=$(basename "$_age_pubfile" .pub)
                _age_key=$(cat "$_age_pubfile")
                echo "  - $_age_name: ${_age_key:0:20}..."
            done
            exit 0
            ;;
        remove|rm)
            # Remove recipient - requires session
            [[ -z "$SESSION_NAME" ]] && error "No session specified. Set CLAUDE_SESSION_NAME or use --session"
            [[ -z "$SECRET_NAME" ]] && error "Usage: age remove <recipient-name>"

            _age_recipients_dir=$(age_recipients_dir "$SESSION_NAME")
            _age_pubfile="$_age_recipients_dir/${SECRET_NAME}.pub"

            if [[ ! -f "$_age_pubfile" ]]; then
                error "Recipient not found: $SECRET_NAME"
            fi

            rm "$_age_pubfile"
            echo "Removed recipient: $SECRET_NAME"
            echo ""
            echo "Note: Existing secrets.age files can still be decrypted by this recipient."
            echo "Re-export secrets to re-encrypt without this recipient."
            exit 0
            ;;
        "")
            error "Usage: age <init|pubkey|add|list|remove>"
            ;;
        *)
            error "Unknown age subcommand: $AGE_SUBCOMMAND"
            ;;
    esac
fi

# Validate session
if [[ -z "$SESSION_NAME" && -n "$COMMAND" ]]; then
    error "No session specified. Set CLAUDE_SESSION_NAME or use --session"
fi

# Execute command
case "$COMMAND" in
    store|set)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        if [[ -z "$SECRET_VALUE" ]]; then
            printf "Enter value for %s: " "$SECRET_NAME"
            read -r SECRET_VALUE
        fi
        [[ -z "$SECRET_VALUE" ]] && error "Secret value cannot be empty"
        backend_store "$SESSION_NAME" "$SECRET_NAME" "$SECRET_VALUE"
        ;;
    get)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        backend_get "$SESSION_NAME" "$SECRET_NAME"
        ;;
    list|ls)
        backend_list "$SESSION_NAME"
        ;;
    delete|rm)
        [[ -z "$SECRET_NAME" ]] && error "Secret name required"
        backend_delete "$SESSION_NAME" "$SECRET_NAME"
        ;;
    purge)
        backend_purge "$SESSION_NAME"
        ;;
    export)
        backend_export "$SESSION_NAME"
        ;;
    export-file)
        # SECRET_NAME holds optional file path argument
        export_to_sync_file "$SESSION_NAME" "$SECRET_NAME"
        ;;
    import-file)
        # SECRET_NAME holds optional file path argument
        import_from_sync_file "$SESSION_NAME" "$SECRET_NAME" "$IMPORT_MODE"
        ;;
    migrate)
        migrate_secrets "$SESSION_NAME" "$DO_REDACT"
        ;;
    migrate-backend)
        [[ -z "$SECRET_NAME" ]] && error "Target backend required. Usage: migrate-backend <backend> [--from <backend>] [--delete-source]"
        migrate_backend "$SESSION_NAME" "$SECRET_NAME" "$DELETE_SOURCE" "$FROM_BACKEND"
        ;;
    "")
        usage
        ;;
    *)
        error "Unknown command: $COMMAND"
        ;;
esac
